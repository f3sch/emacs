#+TITLE: My Emacs Configuration
#+AUTHOR: Felix Schlepper

* Early-Init
This file is loaded before the package system and GUI is initialized.
A detailed description is [[elisp:(info "(emacs) Early Init File")][here]].

** Small Startup Optimizations
This avoids garabage collection during startup.
Afterward, sensible defaults are renabled.

#+begin_src emacs-lisp :tangle early-init.el
  (defvar file-name-handler-alist-old file-name-handler-alist)
  (setq file-name-handler-alist nil
	message-log-max 16384
	gc-cons-threshold most-positive-fixnum
	gc-cons-percentage 0.6)
  (add-hook 'after-init-hook (lambda ()
			       (setq file-name-handler-alist file-name-handler-alist-old
				     gc-cons-threshold (* 16 1024 1024)
				     gc-cons-percentage 0.1)
			       (garbage-collect))
	    t)
#+end_src

** Native Compilation
Asynchronous compilation and speed, enabled.

#+begin_src emacs-lisp :tangle early-init.el
  (let ((path (expand-file-name "eln-cache/" user-emacs-directory)))
    (setq native-comp-eln-load-path (list path)
	  native-compile-target-directory path))
  (setq native-comp-async-report-warnings-errors nil ;; Silence compiler warnings as they can be pretty disruptive
	native-compile-prune-cache t
	native-comp-speed 2
	native-comp-deferred-compilation	 nil)  ;; Make native compilation happens asynchronously

  (setq load-prefer-newer noninteractive)
#+end_src

** Unstyled Emacs
Maximize Frame and do not show unstyled Emacs.

#+begin_src emacs-lisp :tangle early-init.el
  (setq-default frame-inhibit-implied-resize t)
  ;; HACK: Don't show size info (or anything else) in frame title
  (setq-default frame-title-format "\n")
  ;; Disable start-up screen
  (setq-default inhibit-startup-screen t)
  (setq-default inhibit-startup-message t)

  ;; UnsetSRF
  (setq site-run-file nil)
  ;; -UnsetSRF

  ;; Maximize the Emacs frame on startup
  (push '(fullscreen . maximized) initial-frame-alist)
  (push '(fullscreen . maximized) default-frame-alist)

  ;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
  ;; Disable tool and scrollbars. These are just clutter (the scrollbar also
  ;; impacts performance).
  (push '(tool-bar-lines . 0)	default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
  (customize-set-variable 'tool-bar-mode nil)
  (customize-set-variable 'scroll-bar-mode nil)
#+end_src

** Scratch Buffer
Set the scratch buffer initial mode.
This pulls in a whole lot of packages, but I do not care about the startup time.

#+begin_src emacs-lisp :tangle early-init.el
  ;; Fundamental mode at startup.
  (setq initial-major-mode 'emacs-lisp-mode)
#+end_src

** Package.el
Required by straight.el.

#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil)
#+end_src

* Startup
** Load Time
Although I do not care about startup time, I want to see it.

#+begin_src emacs-lisp
    (defconst emacs-start-time (current-time))
    (defun report-time-since-load (&optional suffix)
      (message "Loading init...done (%.3fs)%s"
	       (float-time (time-subtract (current-time) emacs-start-time))
	       suffix))

    (add-hook 'after-init-hook
	      #'(lambda () (report-time-since-load " [after-init]"))
	      t)
#+end_src

** Bootstrap straight.el
For now I use straight.el as a package manager.

#+begin_src emacs-lisp
    (defvar bootstrap-version)
    (let ((bootstrap-file
	   (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	  (bootstrap-version 6))
      (unless (file-exists-p bootstrap-file)
	(with-current-buffer
	    (url-retrieve-synchronously
	     "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
	     'silent 'inhibit-cookies)
	  (goto-char (point-max))
	  (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))
    (setq straight-use-package-by-default t)

      ;;; Paths
    (setq package-user-dir (expand-file-name "packages" user-emacs-directory)
	  url-history-file (expand-file-name "url/history" user-emacs-directory)
	  custom-file (expand-file-name "custom.el" user-emacs-directory))


    (use-package diminish)
#+end_src

* General
** Library Functions
Mostly taken from doomemacs.
#+BEGIN_SRC emacs-lisp
(defmacro appendq! (sym &rest lists)
  "Append LISTS to SYM in place."
  `(setq ,sym (append ,sym ,@lists)))

(defmacro setq! (&rest settings)
  "A more sensible `setopt' for setting customizable variables.

This can be used as a drop-in replacement for `setq' and *should* be used
instead of `setopt'. Unlike `setq', this triggers custom setters on variables.
Unlike `setopt', this won't needlessly pull in dependencies."
  (macroexp-progn
   (cl-loop for (var val) on settings by 'cddr
            collect `(funcall (or (get ',var 'custom-set) #'set-default-toplevel-value)
                              ',var ,val))))

(defmacro delq! (elt list &optional fetcher)
  "`delq' ELT from LIST in-place.

If FETCHER is a function, ELT is used as the key in LIST (an alist)."
  `(setq ,list (delq ,(if fetcher
                          `(funcall ,fetcher ,elt ,list)
                        elt)
                     ,list)))

(defmacro pushnew! (place &rest values)
  "Push VALUES sequentially into PLACE, if they aren't already present.
This is a variadic `cl-pushnew'."
  (let ((var (make-symbol "result")))
    `(dolist (,var (list ,@values) (with-no-warnings ,place))
       (cl-pushnew ,var ,place :test #'equal))))

(defmacro prependq! (sym &rest lists)
  "Prepend LISTS to SYM in place."
  `(setq ,sym (append ,@lists ,sym)))
#+END_SRC

** Config File
A useful variable to have.

#+BEGIN_SRC emacs-lisp
  (defvar +config-file (file-name-concat user-emacs-directory "init.org")
    "User config file.")
#+END_SRC

** No-littering
Stop emacs from littering with sensible defaults to paths.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :demand t
    :diminish
    :config
    ;; save auto-save file if needed
    (setq auto-save-file-name-transforms
	  `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

    ;; exclude these in recentf
    (with-eval-after-load 'recentf
      (appendq! recentf-exclude
		`(,no-littering-var-directory ,no-littering-etc-directory))))
#+END_SRC

** Backups
I don’t use backup files often as I use git to manage most of my files.
However, I still feel safer when having a backup.  Save backup files to a
dedicated directory.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.cache/emacs/backups")))
(with-eval-after-load 'tramp
  (add-to-list 'tramp-backup-directory-alist
	       (cons tramp-file-name-regexp nil)))
(setq delete-old-versions t)
;; Backup also files under VC.
(setq version-control t
      vc-make-backup-files t)
;; Make numeric backup versions unconditionally.
;; auto-save-mode doesn't create the path automatically!
(make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)
(setq auto-save-list-file-prefix
      (expand-file-name "tmp/auto-saves/sessions/" user-emacs-directory))
(setq auto-save-file-name-transforms
      `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t)))
#+END_SRC

** Recent Files
Emacs cleans sometimes up.
I do not need to know when it does...

#+BEGIN_SRC emacs-lisp
  (defun +no-msg (function)
    "Prevent FUNCTION from showing `Wrote <FILE>' messages. (The
  messages are still logged to `*Messages*'.)"
    (let ((inhibit-message  t))	   (funcall function)))
  (advice-add 'recentf-save-list :around '+no-msg)
  (add-hook 'after-init-hook #'recentf-mode)
  (with-eval-after-load 'recentf
    (setq recentf-max-saved-items 300
	  recentf-exclude
	  '("\\.?cache" ".cask" "url" "COMMIT_EDITMSG\\'" "bookmarks"
	    "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\|bmp\\|xpm\\)$"
	    "\\.?ido\\.last$" "\\.revive$" "/G?TAGS$" "/.elfeed/"
	    "^/tmp/" "^/var/folders/.+$" "^/ssh:" "/persp-confs/"
	    (lambda (file) (file-in-directory-p file package-user-dir))))
    (push (expand-file-name recentf-save-file) recentf-exclude)
    (add-to-list 'recentf-filename-handlers #'abbreviate-file-name))
#+END_SRC

** Text Encoding
UTF-8; universally used, but not understood.

#+BEGIN_SRC emacs-lisp
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (set-charset-priority 'unicode)
#+END_SRC

** Blinking Cursor
A cursor is an artifact of video and should blink. Not convinced?
Then read https://www.inverse.com/innovation/blinking-cursor-history

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 1)
#+END_SRC

** Garbage Collection
Let smarter people than me think about GC.

#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :diminish
    :hook (after-init . gcmh-mode)
    :custom
    (gcmh-idle-delay 'auto)
    ;; Garbage-collect on focus-out
    (add-function :after after-focus-change-function
		  (defun +garbage-collect-maybe ()
		    (unless (frame-focus-state)
		      (garbage-collect)))))
#+END_SRC

** Save Place
Saves the last position of pointer in a file.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook #'save-place-mode)
  (setq save-place-forget-unreadable-files nil)
#+END_SRC

** Clipboard
For better clipboard integration in Linux.

#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard t
	select-enable-primary t
	save-interprogram-paste-before-kill t)
#+END_SRC

** CJK Encoding
Me no able speak CJK (Chinese/Japanese/Korean characters).

#+BEGIN_SRC emacs-lisp
  (setq utf-translate-cjk-mode nil)
#+END_SRC

** Line Numbering
I need relative line numbers, so evil can take me where I want to go.

#+BEGIN_SRC emacs-lisp
  (setq display-line-numbers-type 'relative)
#+END_SRC

Activate in all modes deriving from =prog-mode=.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+END_SRC

Explicitly define a width to reduce the cost of on-the-fly computation

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers-width 3)
#+END_SRC

Show absolute line numbers for narrowed regions to make it easier to tell the
buffer is narrowed, and where you are, exactly.

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers-widen t)
#+END_SRC

** Scrolling
Keep text somewhat centered.

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 5
	scroll-step 1)
#+END_SRC

Emacs spends too much effort re-centering the screen if you scroll the cursor
more than N lines past window edges (where N is the settings of
`scroll-conservatively').  This is especially slow in larger files during
large-scale scrolling commands. If kept high enough, the window is never
automatically re-centered.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 10000)
#+END_SRC

Pixel wise precision when scrolling.
#+BEGIN_SRC emacs-lisp
  (pixel-scroll-precision-mode)
#+END_SRC

** Frames
Don't resize the frames in steps; it looks weird, especially in tiling window
managers, where it can leave unseemly gaps.

#+BEGIN_SRC emacs-lisp
  (setq frame-resize-pixelwise t)
#+END_SRC

But do not resize windows pixelwise, this can cause crashes in some cases when
resizing too many windows at once or rapidly.

#+BEGIN_SRC emacs-lisp
  (setq window-resize-pixelwise nil)
#+END_SRC

GUIs are inconsistent across systems, desktop environments, and themes, and
don't match the look of Emacs. They also impose inconsistent shortcut key
paradigms. I'd rather Emacs be responsible for prompting.

#+BEGIN_SRC emacs-lisp
  (setq use-dialog-box nil)
#+END_SRC

Favor vertical splits over horizontal ones. Monitors are trending toward wide,
rather than tall.

#+BEGIN_SRC emacs-lisp
  (setq split-width-threshold 160
	split-height-threshold nil)
#+END_SRC

** Minibuffer
Allow for minibuffer-ception. Sometimes we need another minibuffer command while
we're in the minibuffer.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

Show current key-sequence in minibuffer ala 'set showcmd' in vim. Any feedback
after typing is better UX than no feedback at all.

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.02)
#+END_SRC

Expand the minibuffer to fit multi-line text displayed in the echo-area. This
doesn't look too great with direnv, however...

#+BEGIN_SRC emacs-lisp
  (setq resize-mini-windows 'grow-only)
#+END_SRC


Typing yes/no is obnoxious when y/n will do

#+BEGIN_SRC emacs-lisp
  (setq use-short-answers t)
#+END_SRC

Try to keep the cursor out of the read-only portions of the minibuffer.

#+BEGIN_SRC emacs-lisp
  (setq minibuffer-prompt-properties '(read-only t intangible t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+END_SRC

** Lockfiles
Disable Lockfiles.

#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

** Echo
This is a built-in feature I didn't expect to be useful.  If you type part of
keybinding, Emacs will display this part in the echo area after a timeout.  One
second is a bit too long though for my taste.

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.2)
#+END_SRC

** Display raw bytes as hex
Title says it all.  \x rules \xDEADBEEF

#+BEGIN_SRC emacs-lisp
  (setq display-raw-bytes-as-hex t)
#+END_SRC

** Unconditionally Kill Sub-Processes
Sometimes there processes which do not want to die and then there is vterm.

#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-processes nil)
#+END_SRC

And finally, the prompt that asks you if you want to kill a buffer with a live process attached to it:

#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions
	(remq 'process-kill-buffer-query-function
	      kill-buffer-query-functions))
#+END_SRC

** Scripts
Do not worry chmod a+x something anymore, let emacs do it.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

Also use ~env~ it is more robust in some circumstances.

#+BEGIN_SRC emacs-lisp
  (setq executable-prefix-env t)
#+END_SRC

** Better Matching
CAsE is dump, ignore.

#+BEGIN_SRC emacs-lisp
  (setq read-buffer-completion-ignore-case t
	read-file-name-completion-ignore-case t)
#+END_SRC

** History
Make History a bit longer.

#+BEGIN_SRC emacs-lisp
  (setq-default history-length 10000)
  (setq-default prescient-history-length 10000)
#+END_SRC

Persistent History, have some persistency.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook #'savehist-mode)
  (setq savehist-additional-variables '(mark-ring
					global-mark-ring
					search-ring
					regexp-search-ring
					extended-command-history)
	savehist-autosave-interval 300)
#+END_SRC

** Understand the more common ~sentence~
By default, Emacs thinks a sentence is a full-stop followed by 2 spaces. Let’s make it full-stop and 1 space.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

** Goto Error
Center after going to the next error.

#+BEGIN_SRC emacs-lisp
  (setq next-error-recenter (quote (4)))
#+END_SRC

** Hide Point
Hide the cursor in inactive windows.

#+BEGIN_SRC emacs-lisp
  (setq cursor-in-non-selected-windows nil)
#+END_SRC

** Trashing
Use the system trashing utility iff available.

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

** Fewer Reads
By increasing the maximal read size from a process, we decrease calls to read.
Motivation is not living in the 80s, we have the memory. This should not
increase the pipe maximal size!

#+BEGIN_SRC emacs-lisp
  (setq read-process-output-max (* 2 1024 1024))
#+END_SRC

** Auto revert
Reload file that changed on disk. We can always go back due to undo-tree.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
#+END_SRC

Do the same for remote files.

#+BEGIN_SRC emacs-lisp
  (setq auto-revert-remote-files t)
#+END_SRC

** Tail Messages Buffer
Tail the messages buffer when not in focus.

#+BEGIN_SRC emacs-lisp
  (defvar +messages--auto-tail-enabled nil)
  (defun +messages--auto-tail-a (&rest arg)
    "Make *Messages* buffer auto-scroll to the end after each message. ARG."
    (let* ((buf-name (buffer-name (messages-buffer)))
	   ;; Create *Messages* buffer if it does not exist
	   (buf (get-buffer-create buf-name)))
      ;; Activate this advice only if the point is _not_ in the *Messages* buffer
      ;; to begin with. This condition is required; otherwise you will not be
      ;; able to use `isearch' and other stuff within the *Messages* buffer as
      ;; the point will keep moving to the end of buffer :P
      (when (not (string= buf-name (buffer-name)))
	;; Go to the end of buffer in all *Messages* buffer windows that are
	;; *live* (`get-buffer-window-list' returns a list of only live windows).
	(dolist (win (get-buffer-window-list buf-name nil :all-frames))
	  (with-selected-window win
	    (goto-char (point-max))))
	;; Go to the end of the *Messages* buffer even if it is not in one of
	;; the live windows.
	(with-current-buffer buf
	  (goto-char (point-max))))))
  (defun +messages-auto-tail-toggle ()
    "Auto tail the '*Messages*' buffer."
    (interactive)
    (if +messages--auto-tail-enabled
	(progn
	  (advice-remove 'message '+messages--auto-tail-a)
	  (setq +messages--auto-tail-enabled nil))
      (advice-add 'message :after '+messages--auto-tail-a)
      (setq +messages--auto-tail-enabled t)))
  (+messages-auto-tail-toggle)
#+END_SRC

** Sub-word-mode
Most projects I work on use Camel-Case (ugh!).

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

** Date and Time
Use YYYY-MM-DD date format.

#+BEGIN_SRC emacs-lisp
  (setq calendar-date-style 'iso)
#+END_SRC

** Trailing Whitespace
Clean up trailing whitespaces automatically.

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :diminish
    ;; ws-butler normally preserves whitespace in the buffer (but strips it from
    ;; the written file). While sometimes convenient, this behavior is not
    ;; intuitive. To the average user it looks like whitespace cleanup is failing,
    ;; which causes folks to redundantly install their own.
    :custom
    (ws-butler-keep-whitespace-before-point nil)
    :init
    (ws-butler-global-mode +1))
#+END_SRC

This should not be possible but if ws-butler fails show it.

#+BEGIN_SRC emacs-lisp
(setq show-trailing-whitespace t)
#+END_SRC

** Auto Minor Mode
Better minor mode deduction.

#+BEGIN_SRC emacs-lisp
(use-package auto-minor-mode
  :diminish
  :demand t)
#+END_SRC

** Final Newline
Self-explanatory.

#+BEGIN_SRC emacs-lisp
(setq-default require-final-newline nil)
#+END_SRC

** Path from shell
On Linux Emacs doesn't use the shell PATH if it's not started from
the shell. Let's fix that:

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :init
  (exec-path-from-shell-initialize))
#+END_SRC

** Icons
Nice visual features.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :if (display-graphic-p)
  :commands (all-the-icons-octicon
	     all-the-icons-faicon
	     all-the-icons-fileicon
	     all-the-icons-wicon
	     all-the-icons-material
	     all-the-icons-alltheicon))

(use-package all-the-icons-dired
  :if (display-graphic-p)
  :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC

** Eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :straight (eldoc :type built-in)
    :config
    (setq eldoc-idle-delay 0.0)
    :init
    (global-eldoc-mode))
#+END_SRC

* Keybindings
I use =general= for better keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :straight (general :type git :host github :repo "noctuid/general.el")
    :demand t
    :config
    (general-evil-setup t))
#+END_SRC

Define leader keys.
#+BEGIN_SRC emacs-lisp
  (defconst +leader-key
    "SPC"
    "The global leader key for EVIl.")

  (defconst +local-leader-key
    "SPC m"
    "The local leader key for EVIl.")
#+END_SRC

* Evil
At some point I got used to =vim= keybindings.
Now, I cannot go back.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :straight (evil :type git :host github :repo "emacs-evil/evil")
    :demand t
    :preface
    (setq evil-want-keybinding nil)
    :init
    (evil-mode)
    :custom
    (evil-want-integration t)
    (evil-want-C-g-bindings t)
    (evil-want-C-i-jump nil)
    (evil-want-C-u-scroll t)
    (evil-want-C-u-delete t)
    (evil-want-Y-yank-to-eol t)
    (evil-want-abbrev-expand-on-insert-exit nil)
    (evil-respect-visual-line-mode nil)
    (evil-ex-search-vim-style-regexp t)
    (evil-ex-visual-char-range t)
    (evil-mode-line-format 'nil)
    (evil-symbol-word-search t)
    (evil-default-cursor '+evil-default-cursor-fn)
    (evil-normal-state-cursor 'box)
    (evil-emacs-state-cursor  '(box +evil-emacs-cursor-fn))
    (evil-insert-state-cursor 'bar)
    (evil-visual-state-cursor 'hollow)
    (evil-ex-interactive-search-highlight 'selected-window)
    (evil-kbd-macro-suppress-motion-error t)
    (evil-visual-update-x-selection-p nil)
    :config
    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-set-undo-system 'undo-tree)
    (setq evil-search-module 'evil-search))

  (use-package evil-collection
    :straight (evil-collection :type git :host github :repo "emacs-evil/evil-collection")
    :demand t
    :after evil
    :config
    (evil-collection-init))

  (use-package evil-surround
    :straight (evil-surround :type git :host github :repo "emacs-evil/evil-surround")
    :demand t
    :after evil-collection
    :config
    (global-evil-surround-mode 1))

  (use-package evil-nerd-commenter
    :commands
    (evilnc-comment-operator
     evilnc-inner-comment
     evilnc-outer-commenter)
    :general
    ([remap comment-line] #'evilnc-comment-or-uncomment-lines))
#+END_SRC

* Help
** Which-key
Possibly the greatest package.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init
    (which-key-mode)
    :diminish
    (which-key-mode)
    :custom
    (which-key-idle-delay 0.1)
    (which-key-allow-multiple-replacements t)
    (which-key-sort-order #'which-key-key-order-alpha)
    (which-key-sort-uppercase-first nil)
    (which-key-add-column-padding 1)
    (which-key-max-delay-columns nil)
    (which-key-display-lines 6)
    (which-key-side-window-slot -10)
    :config
    (pushnew!
     which-key-replacement-alist
     '(("" . "\\`+?system-packages[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "\\1"))
     '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "\\1"))
     '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "\\1"))))
#+END_SRC

** Helpful
Help me.

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :commands
    helpful-callable
    helpful-function
    helpful-variable
    helpful-key
    helpful-at-point
    :general
    ([remap describe-callable]    #'helpful-callable)
    ([remap describe-function]    #'helpful-function)
    ([remap describe-variable]    #'helpful-variable)
    ([remap describe-key]         #'helpful-key)
    ([remap view-emacs-debugging] #'helpful-at-point))
#+END_SRC

* Completions
** Basics
*** Orderless Style
#+BEGIN_SRC emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles . (partial-completion)))
				   (eglot (styles . (orderless))))))
#+END_SRC

*** Dabbrev
#+BEGIN_SRC emacs-lisp
  (use-package dabbrev
    ;; Other useful Dabbrev configurations.
    :custom
    (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+END_SRC

*** Marginalia
Provide minibuffer annotations.

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    (marginalia-max-relative-age 0)
    (marginilia-align 'right)
    :init
    (marginalia-mode))
#+END_SRC

*** Icons Completion
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-completion
    :after
    (marginalia all-the-icons)
    :hook
    (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :init
    (all-the-icons-completion-mode))
#+END_SRC

*** Embark
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))
#+END_SRC

** Vertico
For minibuffer completions.

#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :hook
    (after-init . vertico-mode)
    :init
    (vertico-mode)
    :straight (vertico :files (:defaults "extensions/*")
		       :includes (vertico-multiform))
    :bind
    (:map vertico-map
	  ("C-j" . vertico-next)
	  ("C-k" . vertico-previous)
	  ("C-f" . vertico-exit)
	  :map minibuffer-local-map
	  ("M-h" . backward-kill-word))
    :custom
    (vertico-cycle t)
    (vertico-count 10)
    (vertico-count-format '("%-5s " . "%2$s"))
    (vertico-resize t))
#+END_SRC

** consult
[[https://github.com/minad/consult][consult]] provides search and navigation commands based on the Emacs completion
function [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]]. Completion allows you to quickly select an item from a
list of candidates. Consult offers asynchronous and interactive =consult-grep=
and =consult-ripgrep= commands, and the line-based search command
=consult-line=. Furthermore Consult provides an advanced buffer switching
command =consult-buffer= to switch between buffers, recently opened files,
bookmarks and buffer-like candidates from other sources. Some of the Consult
commands are enhanced versions of built-in Emacs commands. For example the
command =consult-imenu= presents a flat list of the Imenu with [[#live-previews][live preview]],
[[#narrowing-and-grouping][grouping and narrowing]]. Please take a look at the [[#available-commands][full list of commands]].

Consult is fully compatible with completion systems centered around the standard
Emacs =completing-read= API, notably the default completion system, [[https://github.com/minad/vertico][Vertico]],
[[https://github.com/protesilaos/mct][Mct]], and [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html][Icomplete]].

This package keeps the completion system specifics to a minimum. The ability of
the Consult commands to work well with arbitrary completion systems is one of
the main advantages of the package. Consult fits well into existing setups and
it helps you to create a full completion environment out of small and
independent components.

#+begin_src emacs-lisp
  (use-package consult
    :straight (consult :type git :host github :repo "minad/consult")
    :bind (("C-c M-x" . consult-mode-command)
	   ("C-c h"   . consult-history)
	   ("C-c K"   . consult-kmacro)
	   ("C-c i"   . consult-info)
	   ([remap Info-search] . consult-info)

	   ("C-*"     . consult-org-heading)
	   ("C-c e l" . find-library)
	   ("C-c e q" . set-variable)
	   ("C-c p f" . project-find-file)

	   ;; C-x bindings (ctl-x-map)
	   ("C-x M-:" . consult-complex-command)
	   ("C-x b"   . consult-buffer)
	   ("C-x 4 b" . consult-buffer-other-window)
	   ("C-x 5 b" . consult-buffer-other-frame)
	   ("C-x r b" . consult-bookmark)
	   ("C-x p b" . consult-project-buffer)
	   ;; Other custom bindings
	   ("M-y"     . consult-yank-pop)
	   ;; M-g bindings (goto-map)
	   ("M-g e"   . consult-compile-error)
	   ("M-g g"   . consult-goto-line)
	   ("M-g M-g" . consult-goto-line)
	   ("M-g l"   . consult-goto-line)
	   ([remap goto-line] . consult-goto-line)
	   ("M-g o"   . consult-org-heading)
	   ("M-g m"   . consult-mark)
	   ("M-g k"   . consult-global-mark)
	   ("M-g i"   . consult-imenu)
	   ("M-g I"   . consult-imenu-multi)
	   ;; M-s bindings (search-map)
	   ("M-s f"   . consult-find)
	   ("M-s M-g" . consult-grep)
	   ("M-s g"   . consult-git-grep)
	   ("M-s r"   . consult-ripgrep)
	   ("M-s l"   . consult-line)
	   ("M-s L"   . consult-line-multi)
	   ("M-s k"   . consult-keep-lines)
	   ("M-s u"   . consult-focus-lines)
	   ;; Isearch integration
	   ("M-s e"   . consult-isearch-history)
	   :map isearch-mode-map
	   ("M-e"     . consult-isearch-history)
	   ("M-s e"   . consult-isearch-history)
	   ("M-s l"   . consult-line)
	   ("M-s L"   . consult-line-multi)
	   ;; Minibuffer history
	   :map minibuffer-local-map
	   ("M-s"     . consult-history)
	   ("M-r"     . consult-history))

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :custom
    (consult-narrow-key "<")
    (consult-async-min-input 1)
    (consult-async-split-style 'semicolon)
    (consult-line-start-from-top t)

    :custom-face
    (consult-file ((t (:inherit font-lock-string-face))))

    :functions
    (consult-register-format
     consult-register-window
     consult-xref)

    ;; The :init configuration is always executed (Not lazy)
    :init
    (with-eval-after-load 'evil
      (evil-global-set-key 'motion "go" #'consult-outline)
      (evil-global-set-key 'motion "gm" #'consult-mark)
      (evil-global-set-key 'motion "gM" #'consult-imenu))

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
	  register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
	  xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    (consult-customize
     consult-theme
     :preview-key '(:debounce 0.2 any)
     consult-ripgrep
     consult-git-grep
     consult-grep
     consult-bookmark
     consult-recent-file
     consult-xref
     consult--source-bookmark
     consult--source-file-register
     consult--source-recent-file
     consult--source-project-recent-file
     :preview-key '(:debounce 0.4 any)))
#+end_src

*** consult-dir

[[https://github.com/karthink/consult-dir][consult-dir]] allows you to easily insert directory paths into the minibuffer
prompt in Emacs.

When using the minibuffer, you can switch - with completion and filtering
provided by your completion setup - to any directory you've visited recently, or
to a project, a bookmarked directory or even a remote host via tramp. The
minibuffer prompt will be replaced with the directory you choose.

Why would you want to do this? To avoid “navigating” long distances when picking
a file or directory in any Emacs command that requires one.

Think of it like the shell tools [[https://github.com/wting/autojump][autojump]], [[https://github.com/clvv/fasd][fasd]] or z but for Emacs. See the
demos section below for many more examples. =consult-dir= works with all Emacs
commands that require you to specify file paths, and with [[https://github.com/oantolin/embark][Embark actions]] on
files.

The directory candidates are collected from user bookmarks, Projectile project
roots (if available), project.el project roots (if available) and recentf file
locations. The =default-directory= variable is not changed in the process.

#+begin_src emacs-lisp
  (use-package consult-dir
    :bind (("M-g d"   . consult-dir)
	   :map minibuffer-local-completion-map
	   ("M-s f" . consult-dir-jump-file)
	   ("M-g d" . consult-dir)))
#+end_src

*** consult-flycheck

#+begin_src emacs-lisp
  (use-package consult-flycheck
    :bind ("M-g f" . consult-flycheck))
#+end_src

*** consult-git-log-grep

#+begin_src emacs-lisp
  (use-package consult-git-log-grep
    :custom
    (consult-git-log-grep-open-function #'magit-show-commit))
#+end_src

*** consult-eglot
#+begin_src emacs-lisp
  (use-package consult-eglot
    :after (eglot consult)
    :general
    ([remap xref-find-apropos] #'consult-eglot-symbols))
#+end_src

*** kind-icon
#+BEGIN_SRC emacs-lisp
(use-package kind-icon
  :after corfu
  :custom
  (kind-icon-default-face 'corfu-default)
  (kind-icon-use-icons t)
  (kind-icon-blend-background nil)
  (kind-icon-blend-frac 0.08)
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+END_SRC

** Corfu
[[https://github.com/minad/corfu][corfu]] enhances completion at point with a small completion popup. The current
candidates are shown in a popup below or above the point. Corfu is the
minimalistic =completion-in-region= counterpart of the [[https://github.com/minad/vertico][Vertico]] minibuffer UI.

Corfu is a small package, which relies on the Emacs completion facilities and
concentrates on providing a polished completion UI. Completions are either
provided by commands like =dabbrev-completion= or by pluggable backends (
=completion-at-point-functions=, Capfs). Most programming language major modes
implement a Capf. The Emacs language server clients use Capfs, which retrieve
completions from the server via the language server protocol (LSP). Corfu does
not include its own completion backends. The Emacs built-in Capfs and the Capfs
provided by other programming language packages are usually sufficient. A few
additional Capfs and completion utilities are provided by the [[https://github.com/minad/cape][Cape]] package.

*NOTE*: Corfu uses child frames to show the popup and falls back to the default
setting of the =completion-in-region-function= on non-graphical displays. If you
want to use Corfu in the terminal, install the package [[https://codeberg.org/akib/emacs-corfu-terminal][corfu-terminal]], which
provides an alternative overlay-based display.

#+begin_src emacs-lisp
  (use-package corfu
    :straight (corfu :type git :host github :repo "minad/corfu"
		     :files (:defaults "extensions/*")
		     :includes (corfu-history
				corfu-popupinfo))
    :demand t
    :bind (("M-/" . completion-at-point)
	   :map corfu-map
	   ("C-n"      . corfu-next)
	   ("C-p"      . corfu-previous)
	   ("<escape>" . corfu-quit)
	   ("<return>" . corfu-insert)
	   ("M-d"      . corfu-info-documentation)
	   ("M-l"      . corfu-info-location)
	   ("M-."      . corfu-move-to-minibuffer))
    :custom
    ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
    ;; want to perform completion
    (tab-always-indent 'complete)
    (completion-cycle-threshold nil)      ; Always show candidates in menu

    ;; Only use `corfu' when calling `completion-at-point' or
    ;; `indent-for-tab-command'
    (corfu-auto t)
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0.1)

    (corfu-min-width 80)
    (corfu-max-width corfu-min-width)     ; Always have the same width
    (corfu-count 14)
    (corfu-scroll-margin 4)
    (corfu-cycle t)

    ;; `nil' means to ignore `corfu-separator' behavior, that is, use the older
    ;; `corfu-quit-at-boundary' = nil behavior. Set this to separator if using
    ;; `corfu-auto' = `t' workflow (in that case, make sure you also set up
    ;; `corfu-separator' and a keybind for `corfu-insert-separator', which my
    ;; configuration already has pre-prepared). Necessary for manual corfu usage with
    ;; orderless, otherwise first component is ignored, unless `corfu-separator'
    ;; is inserted.
    (corfu-quit-at-boundary nil)
    (corfu-separator ?\s)            ; Use space
    (corfu-quit-no-match 'separator) ; Don't quit if there is `corfu-separator' inserted
    (corfu-preview-current 'insert)  ; Preview first candidate. Insert on input if only one
    (corfu-preselect-first t)        ; Preselect first candidate?

    ;; Other
    (corfu-echo-documentation nil)        ; Already use corfu-popupinfo
    :preface
    (defun corfu-enable-always-in-minibuffer ()
      "Enable Corfu in the minibuffer if Vertico/Mct are not active."
      (unless (or (bound-and-true-p mct--active) ; Useful if I ever use MCT
		  (bound-and-true-p vertico--input))
	(setq-local corfu-auto nil)       ; Ensure auto completion is disabled
	(corfu-mode 1)))

    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let (completion-cycle-threshold completion-cycling)
	(apply #'consult-completion-in-region completion-in-region--data)))
    :config
    (global-corfu-mode)
    (corfu-history-mode)

    ;; In EShell enable some special options.
    (add-hook 'eshell-mode-hook
	      (lambda () (setq-local corfu-quit-at-boundary t
				     corfu-quit-no-match t
				     corfu-auto nil)
		(corfu-mode)))

    ;; Show some information in eldoc.
    (eldoc-add-command #'corfu-insert)

    ;; Enable Corfu more generally for every minibuffer, as long as no other
    ;; completion UI is active. If you use Mct or Vertico as your main
    ;; minibuffer completion UI. From
    ;; https://github.com/minad/corfu#completing-with-corfu-in-the-minibuffer
    (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1))
#+end_src

*** corfu-popupinfo

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :bind (:map corfu-map
              ("M-n" . corfu-popupinfo-scroll-up)
              ("M-p" . corfu-popupinfo-scroll-down)
              ([remap corfu-show-documentation] . corfu-popupinfo-toggle))
  :custom
  (corfu-popupinfo-delay 0.5)
  (corfu-popupinfo-max-width 70)
  (corfu-popupinfo-max-height 20)
  ;; Also here to be extra-safe that this is set when `corfu-popupinfo' is
  ;; loaded. I do not want documentation shown in both the echo area and in
  ;; the `corfu-popupinfo' popup.
  (corfu-echo-documentation nil))
#+end_src

** Cape
[[https://github.com/minad/cape][cape]] provides Completion At Point Extensions which can be used in combination
with the [[https://github.com/minad/corfu][Corfu]] completion UI or the default completion UI. The completion
backends used by =completion-at-point= are so called
=completion-at-point-functions= (Capfs). In principle, the Capfs provided by
Cape can also be used by [[https://github.com/company-mode/company-mode][Company]].

Cape has the super power to transform Company backends into Capfs and merge
multiple Capfs into a Super-Capf! These transformers allow you to still take
advantage of Company backends even if you are not using Company as frontend.

#+begin_src emacs-lisp
(use-package cape
  :demand t
  :bind (("C-c . p" . completion-at-point)
         ("C-c . t" . complete-tag)
         ("C-c . d" . cape-dabbrev)
         ("C-c . h" . cape-history)
         ("C-c . f" . cape-file)
         ("C-c . k" . cape-keyword)
         ("C-c . s" . cape-symbol)
         ("C-c . a" . cape-abbrev)
         ("C-c . l" . cape-line)
         ("C-c . w" . cape-dict)
         ("C-c . \\" . cape-tex)
         ("C-c . _" . cape-tex)
         ("C-c . ^" . cape-tex)
         ("C-c . &" . cape-sgml)
         ("C-c . r" . cape-rfc1345))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-abbrev))
#+end_src

* VC
** Basics
Follow symlinks

#+BEGIN_SRC emacs-lisp
  (use-package vc
    :custom
    (vc-command-messages t)
    (vc-follow-symlinks t)
    (vc-git-diff-switches '("-w" "-U3"))
    (vc-make-backup-files t))
#+END_SRC

** Magit
Possibly the most convincing reason to use EMACS? No, seriously it is awesome!

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :hook
    ((magit-process-mode . goto-address-mode))
    :custom
    ;; Update VC line information
    (auto-revert-check-vc-info t)
    ;; Longer commit lines
    (git-commit-summary-max-length 90)
    ;; Show more commits
    (magit-log-section-commit-count 25)
    ;; Do not autosave buffers
    (magit-save-repository-buffers nil)
    ;; Go fullscreen
    (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    ;; Restore previous window configuration
    (magit-bury-buffer-function #'magit-restore-window-configuration)
    ;; Set default clone directory
    (magit-clone-default-directory "~/git/")
    ;; Show more transient levels
    (transient-default-level 7)
    ;; Diffing
    ;; Show granular hunks
    (magit-diff-refine-hunk 'all)
    (magit-diff-refine-ignore-whitespace t)
    (magit-diff-paint-whitespace-lines t)
    :config
    (defvar th/eldoc-git-show-stat--process nil)
    (defun th/eldoc-git-show-stat (callback commit)
      "Compute diffstat for COMMIT asynchronously, then call CALLBACK with it."
      ;; Kill the possibly still running old process and its buffer.
      (when (processp th/eldoc-git-show-stat--process)
	(let ((buf (process-buffer th/eldoc-git-show-stat--process)))
	  (when (process-live-p th/eldoc-git-show-stat--process)
	    (let (confirm-kill-processes)
	      (kill-process th/eldoc-git-show-stat--process)))
	  (when (buffer-live-p buf)
	    (kill-buffer buf))))

      ;; Spawn a new "git show" process.
      (let* ((cmd (list "git" "--no-pager" "show"
			"--no-color"
			;; Author Name <author@email.com>, <date-and-time>
			"--format=format:%an <%ae>, %aD"
			"--stat=80"
			commit)))
	;; An async eldoc-documentation-function must also return a non-nil,
	;; non-string result if it's applicable for computing a documentation
	;; string, so we set and return the new process here.
	(setq th/eldoc-git-show-stat--process
	      (make-process
	       :name "eldoc-git-show"
	       :buffer (generate-new-buffer " *git-show-stat*")
	       :noquery t
	       :command cmd
	       :sentinel (lambda (proc _event)
			   (when (eq (process-status proc) 'exit)
			     (with-current-buffer (process-buffer proc)
			       (goto-char (point-min))
			       (put-text-property (point-min)
						  (line-end-position)
						  'face 'bold)
			       (funcall callback (buffer-string)))))))))
    (defvar th/magit-eldoc-last-commit nil)
    (defun th/magit-eldoc-for-commit (callback)
      (let ((commit (magit-commit-at-point)))
	(when (and commit
		   (not (equal commit th/magit-eldoc-last-commit)))
	  (setq th/magit-eldoc-last-commit commit)
	  (th/eldoc-git-show-stat callback commit))))

    (defun th/magit-eldoc-setup ()
      (add-hook 'eldoc-documentation-functions
		#'th/magit-eldoc-for-commit nil t))

    (add-hook 'magit-status-mode-hook #'th/magit-eldoc-setup)
    (add-hook 'magit-log-mode-hook #'th/magit-eldoc-setup))
#+END_SRC

* Undo
Few understand emacs' kill ring, me included.
Hence Something visually appealing.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :demand t
    :diminish
    :custom
    ;; Show a diff window displaying changes between undo nodes.
    (undo-tree-visualizer-diff t)
    ;; Prevent undo tree files from polluting your git repo
    (undo-tree-history-directory-alist '(("." . "~/.emacs.d/var/undo-tree-hist")))
    :config
    (global-undo-tree-mode +1)
    (setq undo-tree-visualizer-diff t
	  undo-tree-auto-save-history t
	  undo-tree-visualizer-timestamps t
	  undo-tree-enable-undo-in-region t))
#+END_SRC

* Org
** Shortcuts
*** Fast SRC_BLOCK
#+BEGIN_SRC emacs-lisp
  (defun org-insert-src-block (src-code-type)
    "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
    (interactive (let ((src-code-types '("emacs-lisp" "python" "C" "sh" "java" "js"
					 "clojure" "C++" "css" "calc" "asymptote" "dot" "gnuplot" "ledger"
					 "lilypond" "mscgen" "octave" "oz" "plantuml" "R" "sass" "screen" "sql"
					 "awk" "ditaa" "haskell" "latex" "lisp" "matlab" "ocaml" "org" "perl"
					 "ruby" "scheme" "sqlite")))
		   (list (ido-completing-read "Source code type: " src-code-types))))
    (progn (insert (format "#+BEGIN_SRC %s\n" src-code-type))
	   (insert "#+END_SRC\n") (previous-line 2) (org-edit-src-code)))

  (add-hook 'org-mode-hook #'(lambda () ;; keybinding for editing source code blocks
			       (local-set-key (kbd "C-c i e") 'org-edit-src-code) ;; keybinding for inserting code blocks
			       (local-set-key (kbd "C-c i s")
  'org-insert-src-block)))
#+END_SRC

* Programming
** Formatting
#+BEGIN_SRC emacs-lisp
  (use-package apheleia
    :straight (apheleia :type git :host github :repo "radian-software/apheleia")
    :diminish
    :hook prog-mode
    :init
    (apheleia-global-mode +1)
    :config
    ;; Also enable lisp indentation in emacs-lisp
    (push '(emacs-lisp-mode . lisp-indent) apheleia-mode-alist))
#+END_SRC

** Smartparens
Giving parenthesis some brains.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :diminish
    :hook prog-mode
    :commands sp-pair sp-local-pair sp-with-modes sp-point-in-comment sp-point-inside-string
    :custom
    ;; Overlays are too distracting and not terribly helpful. `show-paren-mode' does
    ;; this for us already (and is faster), so...
    (sp-highlight-pair-overlay nil)
    (sp-highlight-wrap-overlay nil)
    (sp-highlight-wrap-tag-and-overlay nil)
    ;; The default is 100, because smartparen's scans are relatively expensive
    ;; (especially with large pair lists for some modes), we reduce it, as a
    ;; better compromise between performance and accuracy.
    (sp-max-prefix-length 25)
    ;; No pair has any business being longer than 4 characters; if they must, set
    ;; it buffer-locally. It's less work for smartparens.
    (sp-max-pair-length 4)
    :config
    (require 'smartparens-config)
    (with-eval-after-load 'evil
      ;; But if someone does want overlays enabled, evil users will be stricken
      ;; with an off-by-one issue where smartparens assumes you're outside the
      ;; pair when you're really at the last character in insert mode. We must
      ;; correct this vile injustice.
      (setq sp-show-pair-from-inside t)
      ;; ...and stay highlighted until we've truly escaped the pair!
      (setq sp-cancel-autoskip-on-backward-movement nil)
      ;; Smartparens conditional binds a key to C-g when sp overlays are active
      ;; (even if they're invisible). This disruptively changes the behavior of
      ;; C-g in insert mode, requiring two presses of the key to exit insert mode.
      ;; I don't see the point of this keybind, so...
      (setq sp-pair-overlay-keymap (make-sparse-keymap))))
#+END_SRC

* EOF
Here, I add the ability to tangle this file automatically when changed and
subsequently saved.

** Tangle Config File
A simple function that tangles this file.

#+BEGIN_SRC emacs-lisp
  (defun +tangle-config () "Tangle the `+config-file'."	 (message "Start
  tangling.")  (require 'org) (org-babel-tangle-file +config-file
  (file-name-concat user-emacs-directory "init.el") "emacs-lisp")
  (message "Successfully tangled config file."))
#+END_SRC

** Add-hook
Emacs considers some file local variables unsafe, e.g., =after-save-hook=.
Hence, I add it as a safe pair, with =+tangle-config= function, to the
=safe-local-variable-values= variable.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'safe-local-variable-values '(after-save-hook
  . +tangle-config))
#+END_SRC

Installs a file local hook, to tangle this file.
# Local Variables:
# after-save-hook: +tangle-config
# eval: (display-line-numbers-mode)
# End:
