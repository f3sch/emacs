#+TITLE: My Emacs Configuration
#+AUTHOR: Felix Schlepper

* Early Init
This file is loaded before the package system and GUI is initialized.
A detailed description is [[elisp:(info "(emacs) Early Init File")][here]].

** SOF
#+BEGIN_SRC emacs-lisp :tangle early-init.el
  ;; early-init.el -*- lexical-binding: t; -*-
#+END_SRC

** Small Startup Optimizations
This avoids garbage collection during startup. Afterward, sensible defaults are re-enabled.

#+begin_src emacs-lisp :tangle early-init.el
  (defvar file-name-handler-alist-old file-name-handler-alist)
  (setq file-name-handler-alist nil
    message-log-max 16384
    gc-cons-threshold most-positive-fixnum
    gc-cons-percentage 0.6)
  (add-hook 'after-init-hook (lambda ()
                   (setq file-name-handler-alist file-name-handler-alist-old
                     gc-cons-threshold (* 16 1024 1024)
                     gc-cons-percentage 0.1)
                   (garbage-collect))
        t)
#+end_src

** Native Compilation
Asynchronous compilation and speed, enabled.

#+begin_src emacs-lisp :tangle early-init.el
  (let ((path (expand-file-name "eln-cache/" (expand-file-name "emacs/" (or (getenv "XDG_CACHE_HOME") "~/.cache")))))
    (setq native-comp-eln-load-path (list path)
          native-compile-target-directory path))
  (setq native-comp-async-report-warnings-errors nil ;; Silence compiler warnings as they can be pretty disruptive
        native-compile-prune-cache t
        native-comp-speed 2
        native-comp-deferred-compilation	 nil)  ;; Make native compilation happens asynchronously
  (when (fboundp 'startup-redirect-eln-cache)
    (startup-redirect-eln-cache
     (convert-standard-filename
      (expand-file-name  "eln-cache/" (expand-file-name "emacs/" (or (getenv "XDG_CACHE_HOME") "~/.cache"))))))

  (setq load-prefer-newer t)
#+end_src

** Unstyled Emacs
Maximize Frame and do not show unstyled Emacs.

#+begin_src emacs-lisp :tangle early-init.el
  (setq-default frame-inhibit-implied-resize t)
  ;; HACK: Don't show size info (or anything else) in frame title
  (setq-default frame-title-format "")
  ;; Disable start-up screen
  (setq-default inhibit-startup-screen t)
  (setq-default inhibit-startup-message t)

  ;; UnsetSRF
  (setq site-run-file nil)
  ;; -UnsetSRF

  ;; Maximize the Emacs frame on startup
  (push '(fullscreen . maximized) initial-frame-alist)
  (push '(fullscreen . maximized) default-frame-alist)

  ;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
  ;; Disable tool and scrollbars. These are just clutter (the scrollbar also
  ;; impacts performance).
  (push '(tool-bar-lines . 0)	default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
  (customize-set-variable 'tool-bar-mode nil)
  (customize-set-variable 'scroll-bar-mode nil)
#+end_src

** Scratch Buffer
Set the scratch buffer initial mode.
This pulls in a whole lot of packages, but I do not care about the startup time.

#+begin_src emacs-lisp :tangle early-init.el
  ;; Fundamental mode at startup.
  (setq initial-major-mode 'emacs-lisp-mode)
#+end_src

** Package.el
Required by straight.el.

#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil)
#+end_src

** EOF
#+begin_src emacs-lisp :tangle early-init.el
  ;; Local Variables:
  ;; coding: utf-8
  ;; no-byte-compile: t
  ;; no-native-compile: t
  ;; no-update-autoloads: t
  ;; End:
  ;;; early-init.el ends here
#+end_src

* Startup
** SOF
#+BEGIN_SRC emacs-lisp
  ;;; init.el --- Load the full configuration -*- lexical-binding: t -*-
#+END_SRC

** Variables
A few useful variables to have.

#+BEGIN_SRC emacs-lisp
  (defvar +config-file (file-name-concat user-emacs-directory "init.org")
    "User config file.")

  (defvar +cache-dir
    (expand-file-name "emacs/" (or (getenv "XDG_CACHE_HOME") "~/.cache"))
    "Cache files represent 'non-essential' data that should not be
  problematic when deleted, lack portability and are regenerated
  when needed without user input.")

  (defvar +user-dir
    (expand-file-name "emacs/" (or (getenv "XDG_CACHE_HOME") "~/.config"))
    "Where your private configuration is placed.")

  (defvar +data-dir
          (expand-file-name "emacs/" (or (getenv-internal "XDG_DATA_HOME") "~/.local/share"))
  "Data files contain shared and long-lived data that Emacs, and their
  packages require to function correctly or at all.

  Use this for: packages, server binaries, package source, pulled module
  libraries, generated files for profiles, profiles themselves,
  autoloads/loaddefs, etc.")

  (defvar +state-dir
          (expand-file-name "emacs/" (or (getenv-internal "XDG_STATE_HOME") "~/.local/state"))
  "State files contain long-lived local configuration data.")
#+END_SRC

** Bootstrap straight.el
For now I use straight.el as a package manager.

#+begin_src emacs-lisp
  (setq straight-use-package-by-default t
        straight-base-dir +data-dir
        straight-cache-autoloads t
        straight-enable-package-integration nil
        straight-build-dir (format "build-%s" emacs-version)
        straight-vc-git-default-clone-depth '(1 single-branch))
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" straight-base-dir))
        (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
    (message "File does not exist; installing...")
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (message bootstrap-file)
    (load bootstrap-file nil 'nomessage))
#+end_src

** Building
Some packages require you to call some special functions for full functionality.

#+BEGIN_SRC emacs-lisp
  (defvar +build-functions nil
    "A LIST of functions that run after building all packages.")
#+END_SRC

Make adding a bit easier.

#+BEGIN_SRC emacs-lisp
  (defun +register-build-function (fn)
      "Add a build function to `+build-functions'."
    (add-to-list '+build-functions fn t))
#+END_SRC

Update command.
#+BEGIN_SRC emacs-lisp
  (defun +update-packages ()
    "Update all install packages."
    (interactive)
    (message "[Emacs]: Creating backups for the current versions of all packages.")
    (let* ((backup-dir (expand-file-name "versions" +data-dir))
           (dest-file (expand-file-name (concat "version-" (format-time-string "%Y%m%d%H%M%S") ".el") backup-dir))
           (src-file (concat straight-base-dir "straight/versions/default.el")))
      (unless (file-directory-p backup-dir)
        (mkdir backup-dir :parents))
      (when (file-exists-p src-file)
        (message "[Emacs]: Creating backup from \"%s\" to \"%s\"" src-file dest-file)
        (copy-file src-file dest-file)))

    ;; (require 'straight-x)
    ;; (message "[Emacs]: Pulling packages")
    ;; (straight-x-pull-all)
    ;; (message "[Emacs]: Freezing packages")
    ;; (straight-x-freeze-versions)
    ;; (message "[Emacs]: Rebuilding packages")
    ;; (straight-rebuild-all)

    ;; Run after build functions
    (message "[Emacs]: Running package-specific build functions")
    (dolist (fn +build-functions)
      (message "[Emacs]: --> Running \"%s\"" fn)
      (cl-letf (((symbol-function 'yes-or-no-p) #'always)
                ((symbol-function 'y-or-n-p) #'always))
        (funcall fn))))
#+END_SRC

** Use-Package
#+begin_src emacs-lisp
  (setq use-package-enable-imenu-support t
        use-package-verbose (not (bound-and-true-p byte-compile-current-file))
        use-package-expand-minimally t
        use-package-compute-statistics nil)
  (setq byte-compile-warnings '(cl-functions))
  (setq ad-redefinition-action 'accept)
#+end_src

** No-littering
Stop emacs from littering with sensible defaults to paths.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :straight (no-littering :type git :host github :repo "emacscollective/no-littering")
    :init
    (setq no-littering-etc-directory (expand-file-name "etc/" +cache-dir)
          no-littering-var-directory (expand-file-name "var/" +cache-dir)
          custom-file (no-littering-expand-etc-file-name "custom.el")))
#+END_SRC

** Benchmark
This is a simple benchmark of calls to Emacs require and load functions. It can
be used to keep track of where time is being spent during Emacs startup in order
to optimize startup times.

#+BEGIN_SRC emacs-lisp
  (use-package benchmark-init
    :straight (benchmark-init :type git :host github :repo "dholm/benchmark-init-el")
    :ensure t
    :config
    ;; To disable collection of benchmark data after init is done.
    (add-hook 'after-init-hook 'benchmark-init/deactivate))
#+END_SRC

** Load Time
Although I do not care about startup time, I want to see it.

#+begin_src emacs-lisp
    (defconst emacs-start-time (current-time))
    (defun report-time-since-load (&optional suffix)
      (message "Loading init...done (%.3fs)%s"
           (float-time (time-subtract (current-time) emacs-start-time))
           suffix))

    (add-hook 'after-init-hook
          #'(lambda () (report-time-since-load " [after-init]"))
          t)
#+end_src

** Security
For the love of all that is holy, do not continue with untrusted connections.

*** GNUTLS
#+BEGIN_SRC emacs-lisp
  (use-package gnutls
    :straight (:type built-in)
    :custom
    (gnutls-verify-error t)
    (gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
    (gnutls-min-prime-bits 3072)
    :config
    (add-to-list 'gnutls-trustfiles "/etc/ssl/cert.pem"))
#+END_SRC

*** NSM
#+BEGIN_SRC emacs-lisp
  (use-package nsm
    :straight (:type built-in)
    :custom
    (network-security-level 'high))
#+END_SRC

* General
** Identity
Some functionality uses this to identify you, e.g. GPG configuration, email
clients, file templates and snippets.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Felix Schlepper"
      user-mail-address "f3sch.git@outlook.com"
      user-login-name "f3sch"
      user-real-login-name "f3sch")
#+END_SRC

** Library Functions
Mostly taken from doomemacs.
#+BEGIN_SRC emacs-lisp
  (defmacro appendq! (sym &rest lists)
    "Append LISTS to SYM in place."
    `(setq ,sym (append ,sym ,@lists)))

  (defmacro setq! (&rest settings)
    "A more sensible `setopt' for setting customizable variables.

      This can be used as a drop-in replacement for `setq' and *should* be used
      instead of `setopt'. Unlike `setq', this triggers custom setters on variables.
      Unlike `setopt', this won't needlessly pull in dependencies."
    (macroexp-progn
     (cl-loop for (var val) on settings by 'cddr
          collect `(funcall (or (get ',var 'custom-set) #'set-default-toplevel-value)
                ',var ,val))))

  (defmacro delq! (elt list &optional fetcher)
    "`delq' ELT from LIST in-place.

      If FETCHER is a function, ELT is used as the key in LIST (an alist)."
    `(setq ,list (delq ,(if fetcher
                `(funcall ,fetcher ,elt ,list)
              elt)
               ,list)))

  (defmacro pushnew! (place &rest values)
    "Push VALUES sequentially into PLACE, if they aren't already present.
      This is a variadic `cl-pushnew'."
    (let ((var (make-symbol "result")))
      `(dolist (,var (list ,@values) (with-no-warnings ,place))
     (cl-pushnew ,var ,place :test #'equal))))

  (defmacro prependq! (sym &rest lists)
    "Prepend LISTS to SYM in place."
    `(setq ,sym (append ,@lists ,sym)))

  (defmacro lambda! (arglist &rest body)
    "Returns (cl-function (lambda ARGLIST BODY...))
  The closure is wrapped in `cl-function', meaning ARGLIST will accept anything
  `cl-defun' will. Implicitly adds `&allow-other-keys' if `&key' is present in
  ARGLIST."
    (declare (indent defun) (doc-string 1) (pure t) (side-effect-free t))
    `(cl-function
      (lambda
    ,(letf! (defun* allow-other-keys (args)
          (mapcar
           (lambda (arg)
             (cond ((nlistp (cdr-safe arg)) arg)
               ((listp arg) (allow-other-keys arg))
               (arg)))
           (if (and (memq '&key args)
                (not (memq '&allow-other-keys args)))
               (if (memq '&aux args)
               (let (newargs arg)
                 (while args
                   (setq arg (pop args))
                   (when (eq arg '&aux)
                 (push '&allow-other-keys newargs))
                   (push arg newargs))
                 (nreverse newargs))
             (append args (list '&allow-other-keys)))
             args)))
       (allow-other-keys arglist))
    ,@body)))

  (defmacro letf! (bindings &rest body)
    "Temporarily rebind function, macros, and advice in BODY.

  Intended as syntax sugar for `cl-letf', `cl-labels', `cl-macrolet', and
  temporary advice.

  BINDINGS is either:

    A list of, or a single, `defun', `defun*', `defmacro', or `defadvice' forms.
    A list of (PLACE VALUE) bindings as `cl-letf*' would accept.

  TYPE is one of:

    `defun' (uses `cl-letf')
    `defun*' (uses `cl-labels'; allows recursive references),
    `defmacro' (uses `cl-macrolet')
    `defadvice' (uses `defadvice!' before BODY, then `undefadvice!' after)

  NAME, ARGLIST, and BODY are the same as `defun', `defun*', `defmacro', and
  `defadvice!', respectively.

  \(fn ((TYPE NAME ARGLIST &rest BODY) ...) BODY...)"
    (declare (indent defun))
    (setq body (macroexp-progn body))
    (when (memq (car bindings) '(defun defun* defmacro defadvice))
      (setq bindings (list bindings)))
    (dolist (binding (reverse bindings) body)
      (let ((type (car binding))
        (rest (cdr binding)))
    (setq
     body (pcase type
        (`defmacro `(cl-macrolet ((,@rest)) ,body))
        (`defadvice `(progn (defadvice! ,@rest)
                    (unwind-protect ,body (undefadvice! ,@rest))))
        ((or `defun `defun*)
         `(cl-letf ((,(car rest) (symbol-function #',(car rest))))
            (ignore ,(car rest))
            ,(if (eq type 'defun*)
             `(cl-labels ((,@rest)) ,body)
               `(cl-letf (((symbol-function #',(car rest))
                   (lambda! ,(cadr rest) ,@(cddr rest))))
              ,body))))
        (_
         (when (eq (car-safe type) 'function)
           (setq type (list 'symbol-function type)))
         (list 'cl-letf (list (cons type rest)) body)))))))


  (defmacro quiet! (&rest forms)
    "Run FORMS without generating any output.

    This silences calls to `message', `load', `write-region' and anything that
    writes to `standard-output'. In interactive sessions this inhibits output to the
    echo-area, but not to *Messages*."
    `(if init-file-debug
     (progn ,@forms)
       ,(if noninteractive
        `(letf! ((standard-output (lambda (&rest _)))
             (defun message (&rest _))
             (defun load (file &optional noerror nomessage nosuffix must-suffix)
               (funcall load file noerror t nosuffix must-suffix))
             (defun write-region (start end filename &optional append visit lockname mustbenew)
               (unless visit (setq visit 'no-message))
               (funcall write-region start end filename append visit lockname mustbenew)))
            ,@forms)
      `(let ((inhibit-message t)
         (save-silently t))
         (prog1 ,@forms (message ""))))))


  (defun doom-shut-up-a (fn &rest args)
    "Generic advisor for silencing noisy functions.

      In interactive Emacs, this just inhibits messages from appearing in the
      minibuffer. They are still logged to *Messages*.

      In tty Emacs, messages are suppressed completely."
    (quiet! (apply fn args)))
  ;;; Definers
  (defmacro defadvice! (symbol arglist &optional docstring &rest body)
    "Define an advice called SYMBOL and add it to PLACES.

  ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
  PLACE is the function to which to add the advice, like in `advice-add'.
  DOCSTRING and BODY are as in `defun'.

  \(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
    (declare (doc-string 3) (indent defun))
    (unless (stringp docstring)
      (push docstring body)
      (setq docstring nil))
    (let (where-alist)
      (while (keywordp (car body))
        (push `(cons ,(pop body) (ensure-list ,(pop body)))
              where-alist))
      `(progn
         (defun ,symbol ,arglist ,docstring ,@body)
         (dolist (targets (list ,@(nreverse where-alist)))
           (dolist (target (cdr targets))
             (advice-add target (car targets) #',symbol))))))

  (defmacro undefadvice! (symbol _arglist &optional docstring &rest body)
    "Undefine an advice called SYMBOL.

  This has the same signature as `defadvice!' an exists as an easy undefiner when
  testing advice (when combined with `rotate-text').

  \(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
    (declare (doc-string 3) (indent defun))
    (let (where-alist)
      (unless (stringp docstring)
        (push docstring body))
      (while (keywordp (car body))
        (push `(cons ,(pop body) (ensure-list ,(pop body)))
              where-alist))
      `(dolist (targets (list ,@(nreverse where-alist)))
         (dolist (target (cdr targets))
           (advice-remove target #',symbol)))))
#+END_SRC

** Packages
Commonly used packages.

#+BEGIN_SRC emacs-lisp
  (use-package hydra)
  (use-package async)
#+END_SRC

** Backups
I don’t use backup files often as I use git to manage most of my files. However,
I still feel safer when having a backup. Save backup files to a dedicated
directory.

#+BEGIN_SRC emacs-lisp
  (setq delete-old-versions t)
  ;; Backup also files under VC.
  (setq version-control t
        vc-make-backup-files t)
  (setq backup-directory-alist
        `((,(concat "\\`" (file-name-as-directory temporary-file-directory)))
          ("\\`/tmp/" . nil)
          ("\\`/dev/shm/" . nil)
          ("." . ,(no-littering-expand-var-file-name "backup/"))))
  (setq auto-save-file-name-transforms
        `(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'"
           ,(concat (file-name-as-directory temporary-file-directory) "\\2") t)
          ("\\`/tmp\\([^/]*/\\)*\\(.*\\)\\'" "\\2")
          ("\\`/dev/shm\\([^/]*/\\)*\\(.*\\)\\'" "\\2")
          (".*" ,(no-littering-expand-var-file-name "auto-saves/") t)))
  (setq auto-save-list-file-prefix
        (no-littering-expand-var-file-name "auto-saves/sessions/"))
#+END_SRC

** Recent Files
Emacs cleans sometimes up.
I do not need to know when it does...

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :straight (:type built-in)
    :hook (after-init . recentf-mode)
    :custom
    (recentf-max-saved-items 300)
    (recentf-save-file (concat +cache-dir "recentf"))
    (recentf-exclude
     '("\\.?cache" ".cask" "url" "COMMIT_EDITMSG\\'" "bookmarks"
       "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\|bmp\\|xpm\\)$"
       "\\.?ido\\.last$" "\\.revive$" "/G?TAGS$" "/.elfeed/"
       "^/tmp/" "^/var/folders/.+$" "^/ssh:" "/persp-confs/"
       (concat "^" (regexp-quote (or (getenv "XDG_RUNTIME_DIR")
                     "/run")))
       (lambda (file) (file-in-directory-p file package-user-dir))))
    :config

    ;; exclude no-littering in recentf
    (appendq! recentf-exclude '(,no-littering-var-directory ,no-littering-etc-directory))
    (advice-add 'recentf-save-list :around #'doom-shut-up-a)
    (push (expand-file-name recentf-save-file) recentf-exclude)
    (add-to-list 'recentf-filename-handlers #'abbreviate-file-name)
    (setq recentf-auto-cleanup   (if (daemonp) 300))
    (add-hook 'kill-emacs #'recentf-cleanup))
#+END_SRC

** Text Encoding
UTF-8; universally used, but not understood.

#+BEGIN_SRC emacs-lisp
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (set-charset-priority 'unicode)
#+END_SRC

** Blinking Cursor
A cursor is an artifact of video and should blink. Not convinced?
Then read https://www.inverse.com/innovation/blinking-cursor-history

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 1)
#+END_SRC

** Garbage Collection
Let smarter people than me think about GC.

#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :hook (after-init . gcmh-mode)
    :custom
    (gcmh-idle-delay 'auto)
    ;; Garbage-collect on focus-out
    (add-function :after after-focus-change-function
          (defun +garbage-collect-maybe ()
            (unless (frame-focus-state)
              (garbage-collect)))))
#+END_SRC

** Save Place
Saves the last position of pointer in a file.

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :straight (:type built-in)
    :hook (after-init . save-place-mode)
    :custom
    (save-place-file (concat +cache-dir "saveplace"))
    (save-place-forget-unreadable-files t))
#+END_SRC

** Server
Embrace the daemon.

#+BEGIN_SRC emacs-lisp
  (use-package server
    :when (display-graphic-p)
    :straight (:type built-in)
    :defer 10
    :config
    (when-let (name (getenv "EMACS_SERVER_NAME"))
      (setq server-name name))
    (unless (server-running-p)
      (server-start)))
#+END_SRC

** Autorevert
#+BEGIN_SRC emacs-lisp
  (use-package autorevert
    ;; revert buffers when their files/state have changed
    :straight (:type built-in)
    :hook (after-init . global-auto-revert-mode)
    :config
    (setq auto-revert-verbose t ; let us know when it happens
      auto-revert-use-notify nil
      auto-revert-stop-on-user-input nil
      ;; Only prompts for confirmation when buffer is unsaved.
      revert-without-query (list ".")))
#+END_SRC

** General.el
I use =general= for better keybindings.
This is provided early so that I can use the =:general= keyword in =use-package=.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :straight (general :type git :host github :repo "noctuid/general.el")
    :demand t
    :config
    (general-evil-setup t))
#+END_SRC

*** Leader Keys
Define leader keys.
#+BEGIN_SRC emacs-lisp
  (general-create-definer +leader-key
    :states '(normal visual emacs)
    :keymaps 'override
    :prefix "SPC"
    :global-prefix "C-SPC")

  (general-create-definer +local-leader-key
    :states '(normal visual emacs)
    :keymaps 'override
    :prefix "SPC m"
    :global-prefix "M-m")

  (general-create-definer +evil
    :states '(normal))
#+END_SRC

** Visible Bell
The first visual setting in this section will activate the visible bell. What it
does is I get a visual feedback each time I do something Emacs doesn’t agree
with, like tring to go up a line when I’m already at the top of the buffer.

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

** Cursor
It is nicer to see a cursor cover the actual space of a character.

#+BEGIN_SRC emacs-lisp
  (setq x-stretch-cursor t)
#+END_SRC

** Ellipsed Text
When text is ellipsed, I want the ellipsis marker to be a single character of
three dots. Let’s make it so:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'mule-util
    (setq truncate-string-ellipsis "…"))
#+END_SRC

This also applies to sexp expressions.
#+BEGIN_SRC emacs-lisp
  ;; remove ellipsis when printing sexps in message buffer
  (setq eval-expression-print-length nil
        eval-expression-print-level  nil)
#+END_SRC

** Formatting
#+BEGIN_SRC emacs-lisp
  ;; Favor spaces over tabs. Pls dun h8, but I think spaces (and 4 of them) is a
  ;; more consistent default than 8-space tabs. It can be changed on a per-mode
  ;; basis anyway (and is, where tabs are the canonical style, like go-mode).
  (setq-default indent-tabs-mode nil
        tab-width 4)

  ;; Only indent the line when at BOL or in a line's indentation. Anywhere else,
  ;; insert literal indentation.
  (setq-default tab-always-indent nil)

  ;; Make `tabify' and `untabify' only affect indentation. Not tabs/spaces in the
  ;; middle of a line.
  (setq tabify-regexp "^\t* [ \t]+")

  ;; An archaic default in the age of widescreen 4k displays? I disagree. We still
  ;; frequently split our terminals and editor frames, or have them side-by-side,
  ;; using up more of that newly available horizontal real-estate.
  (setq-default fill-column 80)

  ;; Continue wrapped words at whitespace, rather than in the middle of a word.
  (setq-default word-wrap t)
  ;; ...but don't do any wrapping by default. It's expensive. Enable
  ;; `visual-line-mode' if you want soft line-wrapping. `auto-fill-mode' for hard
  ;; line-wrapping.
  (setq-default truncate-lines t)
  ;; If enabled (and `truncate-lines' was disabled), soft wrapping no longer
  ;; occurs when that window is less than `truncate-partial-width-windows'
  ;; characters wide. We don't need this, and it's extra work for Emacs otherwise,
  ;; so off it goes.
  (setq truncate-partial-width-windows nil)

  ;; This was a widespread practice in the days of typewriters. I actually prefer
  ;; it when writing prose with monospace fonts, but it is obsolete otherwise.
  (setq sentence-end-double-space nil)

  ;; The POSIX standard defines a line is "a sequence of zero or more non-newline
  ;; characters followed by a terminating newline", so files should end in a
  ;; newline. Windows doesn't respect this (because it's Windows), but we should,
  ;; since programmers' tools tend to be POSIX compliant (and no big deal if not).
  (setq require-final-newline t)

  ;; Default to soft line-wrapping in text modes. It is more sensibile for text
  ;; modes, even if hard wrapping is more performant.
  (add-hook 'text-mode-hook #'visual-line-mode)
#+END_SRC

** Clipboard
For better clipboard integration in Linux.

#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard t
    select-enable-primary t
    save-interprogram-paste-before-kill t)

  (setq x-select-request-type     '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
        x-select-enable-clipboard t
        x-select-enable-primary   t
        x-stretch-cursor          t)
#+END_SRC

** CJK Encoding
Me no able speak CJK (Chinese/Japanese/Korean characters).

#+BEGIN_SRC emacs-lisp
  (setq utf-translate-cjk-mode nil)
#+END_SRC

** Line Numbering
I need relative line numbers, so evil can take me where I want to go.

#+BEGIN_SRC emacs-lisp
  (setq display-line-numbers-type 'relative)
#+END_SRC

Activate in all modes deriving from =prog-mode=.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+END_SRC

Explicitly define a width to reduce the cost of on-the-fly computation

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers-width 3)
#+END_SRC

Show absolute line numbers for narrowed regions to make it easier to tell the
buffer is narrowed, and where you are, exactly.

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers-widen t)
#+END_SRC

** Scrolling
Keep text somewhat centered.

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 5
    scroll-step 1)
#+END_SRC

Emacs spends too much effort re-centering the screen if you scroll the cursor
more than N lines past window edges (where N is the settings of
`scroll-conservatively').  This is especially slow in larger files during
large-scale scrolling commands. If kept high enough, the window is never
automatically re-centered.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 10000)
#+END_SRC

Pixel wise precision when scrolling.
#+BEGIN_SRC emacs-lisp
  (pixel-scroll-precision-mode)
#+END_SRC

** Frames
Don't resize the frames in steps; it looks weird, especially in tiling window
managers, where it can leave unseemly gaps.

#+BEGIN_SRC emacs-lisp
  (setq frame-resize-pixelwise t)
#+END_SRC

But do not resize windows pixelwise, this can cause crashes in some cases when
resizing too many windows at once or rapidly.

#+BEGIN_SRC emacs-lisp
  (setq window-resize-pixelwise nil
        window-combination-resize t)
#+END_SRC

GUIs are inconsistent across systems, desktop environments, and themes, and
don't match the look of Emacs. They also impose inconsistent shortcut key
paradigms. I'd rather Emacs be responsible for prompting.

#+BEGIN_SRC emacs-lisp
  (setq use-dialog-box nil)
#+END_SRC

Favor vertical splits over horizontal ones. Monitors are trending toward wide,
rather than tall.

#+BEGIN_SRC emacs-lisp
  (setq split-width-threshold 160
    split-height-threshold nil)
#+END_SRC

** Exit Emacs
#+BEGIN_SRC emacs-lisp
  (setopt confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

** Lockfiles
Disable Lockfiles.

#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

** Echo
This is a built-in feature I didn't expect to be useful.  If you type part of
keybinding, Emacs will display this part in the echo area after a timeout.  One
second is a bit too long though for my taste.

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.2)
#+END_SRC

** Display raw bytes as hex
Title says it all.  \x rules \xDEADBEEF

#+BEGIN_SRC emacs-lisp
  (setq display-raw-bytes-as-hex t)
#+END_SRC

** Unconditionally Kill Sub-Processes
Sometimes there processes which do not want to die and then there is vterm.

#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-processes nil)
#+END_SRC

And finally, the prompt that asks you if you want to kill a buffer with a live process attached to it:

#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions
    (remq 'process-kill-buffer-query-function
          kill-buffer-query-functions))
#+END_SRC

** Scripts
Do not worry chmod a+x something anymore, let emacs do it.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

Also use ~env~ it is more robust in some circumstances.

#+BEGIN_SRC emacs-lisp
  (setq executable-prefix-env t)
#+END_SRC

** Better Matching
CAsE is dump, ignore.

#+BEGIN_SRC emacs-lisp
  (setq read-buffer-completion-ignore-case t
    read-file-name-completion-ignore-case t)
#+END_SRC

** History
Make History a bit longer.

#+BEGIN_SRC emacs-lisp
  (setq-default history-length 10000)
#+END_SRC

Persistent History, have some persistency.

#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :straight (:type built-in)
    :hook (after-init . savehist-mode)
    :custom
    (savehist-file (concat +cache-dir "savehist"))
    (savehist-additional-variables '(mark-ring global-mark-ring
                           search-ring regexp-search-ring compile-history
                           register-alist kill-ring
                           extended-command-history))
    (savehist-save-minibuffer-history t)
    (savehist-autosave-interval 60))
#+END_SRC

** Understand the more common ~sentence~
By default, Emacs thinks a sentence is a full-stop followed by 2 spaces. Let’s make it full-stop and 1 space.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

** Goto Error
Center after going to the next error.

#+BEGIN_SRC emacs-lisp
  (setq next-error-recenter (quote (4)))
#+END_SRC

** Hide Point
Hide the cursor in inactive windows.

#+BEGIN_SRC emacs-lisp
  (setq cursor-in-non-selected-windows nil)
#+END_SRC

** Trashing
Use the system trashing utility iff available.

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

** Fewer Reads
By increasing the maximal read size from a process, we decrease calls to read.
Motivation is not living in the 80s, we have the memory. This should not
increase the pipe maximal size!

#+BEGIN_SRC emacs-lisp
  (setq read-process-output-max (* 1024 1024))
#+END_SRC

** Auto revert
Reload file that changed on disk. We can always go back due to undo-tree.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
#+END_SRC

Do the same for remote files.

#+BEGIN_SRC emacs-lisp
  (setq auto-revert-remote-files t)
#+END_SRC

** Tail Messages Buffer
Tail the messages buffer when not in focus.

#+BEGIN_SRC emacs-lisp
  (defvar +messages--auto-tail-enabled nil)
  (defun +messages--auto-tail-a (&rest arg)
    "Make *Messages* buffer auto-scroll to the end after each message. ARG."
    (let* ((buf-name (buffer-name (messages-buffer)))
       ;; Create *Messages* buffer if it does not exist
       (buf (get-buffer-create buf-name)))
      ;; Activate this advice only if the point is _not_ in the *Messages* buffer
      ;; to begin with. This condition is required; otherwise you will not be
      ;; able to use `isearch' and other stuff within the *Messages* buffer as
      ;; the point will keep moving to the end of buffer :P
      (when (not (string= buf-name (buffer-name)))
    ;; Go to the end of buffer in all *Messages* buffer windows that are
    ;; *live* (`get-buffer-window-list' returns a list of only live windows).
    (dolist (win (get-buffer-window-list buf-name nil :all-frames))
      (with-selected-window win
        (goto-char (point-max))))
    ;; Go to the end of the *Messages* buffer even if it is not in one of
    ;; the live windows.
    (with-current-buffer buf
      (goto-char (point-max))))))
  (defun +messages-auto-tail-toggle ()
    "Auto tail the '*Messages*' buffer."
    (interactive)
    (if +messages--auto-tail-enabled
    (progn
      (advice-remove 'message '+messages--auto-tail-a)
      (setq +messages--auto-tail-enabled nil))
      (advice-add 'message :after '+messages--auto-tail-a)
      (setq +messages--auto-tail-enabled t)))
  (+messages-auto-tail-toggle)
#+END_SRC

** Sub-word-mode
Most projects I work on use Camel-Case (ugh!).

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

** Date and Time
Use YYYY-MM-DD date format.

#+BEGIN_SRC emacs-lisp
  (setq calendar-date-style 'iso)
#+END_SRC

** Trailing Whitespace
Clean up trailing whitespaces automatically.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :straight (:type built-in)
    ;; clean up by default
    :hook (before-save . whitespace-cleanup)
    :custom
    ;; Turn off by default
    (show-trailing-whitespace nil))
#+END_SRC

** Auto Minor Mode
Better minor mode deduction.

#+BEGIN_SRC emacs-lisp
(use-package auto-minor-mode
  :demand t)
#+END_SRC

** Final Newline
Self-explanatory.

#+BEGIN_SRC emacs-lisp
(setq-default require-final-newline nil)
#+END_SRC

** Path from shell
On Linux Emacs doesn't use the shell PATH if it's not started from
the shell. Let's fix that:

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :init
  (exec-path-from-shell-initialize))
#+END_SRC

** SubWord
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

** Icons
Nice visual features.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p)
    :commands (all-the-icons-octicon
           all-the-icons-faicon
           all-the-icons-fileicon
           all-the-icons-wicon
           all-the-icons-material
           all-the-icons-alltheicon)
    :config
    (+register-build-function #'all-the-icons-install-fonts))

  (use-package all-the-icons-dired
    :if (display-graphic-p)
    :after all-the-icons
    :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC

** Eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :straight (eldoc :type built-in)
    :preface
    (add-to-list 'display-buffer-alist
                 '("^\\*eldoc for" display-buffer-at-bottom
                   (window-height . 4)))
    :custom
    (eldoc-idle-delay 0.1)
    (eldoc-documentation-strategy 'eldoc-documentation-compose-eagerly)
    :config
    (eldoc-add-command-completions "paredit-")
    (eldoc-add-command-completions "combobulate-")
    :init
    (global-eldoc-mode))
#+END_SRC

** Modeline
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode)
    :config
    (use-package nerd-icons
      :config
      (+register-build-function #'nerd-icons-install-fonts))
    :custom
    ;; If non-nil, cause imenu to see `doom-modeline' declarations.
    ;; This is done by adjusting `lisp-imenu-generic-expression' to
    ;; include support for finding `doom-modeline-def-*' forms.
    ;; Must be set before loading doom-modeline.
    (doom-modeline-support-imenu t)

    ;; How tall the mode-line should be. It's only respected in GUI.
    ;; If the actual char height is larger, it respects the actual height.
    (doom-modeline-height 35)

    ;; How wide the mode-line bar should be. It's only respected in GUI.
    (doom-modeline-bar-width 4)

    ;; Whether to use hud instead of default bar. It's only respected in GUI.
    (doom-modeline-hud nil)

    ;; The limit of the window width.
    ;; If `window-width' is smaller than the limit, some information won't be
    ;; displayed. It can be an integer or a float number. `nil' means no limit."
    (doom-modeline-window-width-limit 85)

    ;; How to detect the project root.
    ;; nil means to use `default-directory'.
    ;; The project management packages have some issues on detecting project root.
    ;; e.g. `projectile' doesn't handle symlink folders well, while `project' is unable
    ;; to hanle sub-projects.
    ;; You can specify one if you encounter the issue.
    (doom-modeline-project-detection 'project)

    ;; Determines the style used by `doom-modeline-buffer-file-name'.
    ;;
    ;; Given ~/Projects/FOSS/emacs/lisp/comint.el
    ;;   auto => emacs/l/comint.el (in a project) or comint.el
    ;;   truncate-upto-project => ~/P/F/emacs/lisp/comint.el
    ;;   truncate-from-project => ~/Projects/FOSS/emacs/l/comint.el
    ;;   truncate-with-project => emacs/l/comint.el
    ;;   truncate-except-project => ~/P/F/emacs/l/comint.el
    ;;   truncate-upto-root => ~/P/F/e/lisp/comint.el
    ;;   truncate-all => ~/P/F/e/l/comint.el
    ;;   truncate-nil => ~/Projects/FOSS/emacs/lisp/comint.el
    ;;   relative-from-project => emacs/lisp/comint.el
    ;;   relative-to-project => lisp/comint.el
    ;;   file-name => comint.el
    ;;   buffer-name => comint.el<2> (uniquify buffer name)
    ;;
    ;; If you are experiencing the laggy issue, especially while editing remote files
    ;; with tramp, please try `file-name' style.
    ;; Please refer to https://github.com/bbatsov/projectile/issues/657.
    (doom-modeline-buffer-file-name-style 'auto)

    ;; Whether display icons in the mode-line.
    ;; While using the server mode in GUI, should set the value explicitly.
    (doom-modeline-icon t)

    ;; Whether display the icon for `major-mode'. It respects `doom-modeline-icon'.
    (doom-modeline-major-mode-icon t)

    ;; Whether display the colorful icon for `major-mode'.
    ;; It respects `nerdg-icons-color-icons'.
    (doom-modeline-major-mode-color-icon t)

    ;; Whether display the icon for the buffer state. It respects `doom-modeline-icon'.
    (doom-modeline-buffer-state-icon t)

    ;; Whether display the modification icon for the buffer.
    ;; It respects `doom-modeline-icon' and `doom-modeline-buffer-state-icon'.
    (doom-modeline-buffer-modification-icon t)

    ;; Whether display the time icon. It respects variable `doom-modeline-icon'.
    (doom-modeline-time-icon t)

    ;; Whether to use unicode as a fallback (instead of ASCII) when not using icons.
    (doom-modeline-unicode-fallback nil)

    ;; Whether display the buffer name.
    (doom-modeline-buffer-name t)

    ;; Whether highlight the modified buffer name.
    (doom-modeline-highlight-modified-buffer-name t)

    ;; Whether display the minor modes in the mode-line.
    (doom-modeline-minor-modes nil)

    ;; If non-nil, a word count will be added to the selection-info modeline segment.
    (doom-modeline-enable-word-count nil)

    ;; Major modes in which to display word count continuously.
    ;; Also applies to any derived modes. Respects `doom-modeline-enable-word-count'.
    ;; If it brings the sluggish issue, disable `doom-modeline-enable-word-count' or
    ;; remove the modes from `doom-modeline-continuous-word-count-modes'.
    (doom-modeline-continuous-word-count-modes '(markdown-mode gfm-mode org-mode))

    ;; Whether display the buffer encoding.
    (doom-modeline-buffer-encoding t)

    ;; Whether display the indentation information.
    (doom-modeline-indent-info nil)

    ;; If non-nil, only display one number for checker information if applicable.
    (doom-modeline-checker-simple-format nil)

    ;; The maximum number displayed for notifications.
    (doom-modeline-number-limit 0)

    ;; The maximum displayed length of the branch name of version control.
    (doom-modeline-vcs-max-length 12)

    ;; Whether display the workspace name. Non-nil to display in the mode-line.
    (doom-modeline-workspace-name t)

    ;; Whether display the perspective name. Non-nil to display in the mode-line.
    (doom-modeline-persp-name t)

    ;; If non nil the default perspective name is displayed in the mode-line.
    (doom-modeline-display-default-persp-name nil)

    ;; If non nil the perspective name is displayed alongside a folder icon.
    (doom-modeline-persp-icon t)

    ;; Whether display the `lsp' state. Non-nil to display in the mode-line.
    (doom-modeline-lsp t)

    ;; Whether display the GitHub notifications. It requires `ghub' package.
    (doom-modeline-github nil)

    ;; The interval of checking GitHub.
    (doom-modeline-github-interval (* 30 60))

    ;; Whether display the modal state.
    ;; Including `evil', `overwrite', `god', `ryo' and `xah-fly-keys', etc.
    (doom-modeline-modal t)

    ;; Whether display the modal state icon.
    ;; Including `evil', `overwrite', `god', `ryo' and `xah-fly-keys', etc.
    (doom-modeline-modal-icon t)

    ;; Whether display the mu4e notifications. It requires `mu4e-alert' package.
    (doom-modeline-mu4e nil)
    ;; also enable the start of mu4e-alert
    ;;(mu4e-alert-enable-mode-line-display)

    ;; Whether display the gnus notifications.
    (doom-modeline-gnus nil)

    ;; Whether gnus should automatically be updated and how often (set to 0 or smaller than 0 to disable)
    (doom-modeline-gnus-timer -1)

    ;; Wheter groups should be excludede when gnus automatically being updated.
    (doom-modeline-gnus-excluded-groups '("dummy.group"))

    ;; Whether display the IRC notifications. It requires `circe' or `erc' package.
    (doom-modeline-irc nil)

    ;; Function to stylize the irc buffer names.
    (doom-modeline-irc-stylize 'identity)

    ;; Whether display the battery status. It respects `display-battery-mode'.
    (doom-modeline-battery nil)

    ;; Whether display the time. It respects `display-time-mode'.
    (doom-modeline-time nil)

    ;; Whether display the misc segment on all mode lines.
    ;; If nil, display only if the mode line is active.
    (doom-modeline-display-misc-in-all-mode-lines t)

    ;; Whether display the environment version.
    (doom-modeline-env-version t)
    ;; Or for individual languages
    (doom-modeline-env-enable-python t)
    (doom-modeline-env-enable-ruby nil)
    (doom-modeline-env-enable-perl nil)
    (doom-modeline-env-enable-go nil)
    (doom-modeline-env-enable-elixir nil)
    (doom-modeline-env-enable-rust t)

    ;; Change the executables to use for the language version string
    (doom-modeline-env-python-executable "python") ; or `python-shell-interpreter'
    (doom-modeline-env-ruby-executable "ruby")
    (doom-modeline-env-perl-executable "perl")
    (doom-modeline-env-go-executable "go")
    (doom-modeline-env-elixir-executable "iex")
    (doom-modeline-env-rust-executable "rustc")

    ;; What to display as the version while a new one is being loaded
    (doom-modeline-env-load-string "...")

    ;; By default, almost all segments are displayed only in the active window. To
    ;; display such segments in all windows, specify e.g.
    (doom-modeline-always-visible-segments '(mu4e irc))

    ;; Hooks that run before/after the modeline version string is updated
    (doom-modeline-before-update-env-hook nil)
    (doom-modeline-after-update-env-hook nil)
    :config
    (defun doom-modeline-conditional-buffer-encoding ()
      "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
      (setq-local doom-modeline-buffer-encoding
                  (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                     '(coding-category-undecided coding-category-utf-8))
                               (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                    t)))

    (add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding))
#+END_SRC

** Theme
*** Doom
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :disabled t
    :ensure t
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
      doom-themes-enable-italic t) ; if nil, italics is universally disabled
    (load-theme 'doom-one t)

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    ;; Enable custom neotree theme (all-the-icons must be installed!)
    (doom-themes-neotree-config)
    ;; or for treemacs users
    (setq doom-themes-treemacs-theme "doom-atom") ; use "doom-colors" for less minimal icon theme
    (doom-themes-treemacs-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+END_SRC

*** Modus
#+BEGIN_SRC emacs-lisp
  (use-package modus-themes
    :straight (:type built-in)
    :init (require-theme 'modus-themes)
    :config
    ;; In all of the following, WEIGHT is a symbol such as `semibold',
    ;; `light', `bold', or anything mentioned in `modus-themes-weights'.
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs nil
          modus-themes-mixed-fonts t
          modus-themes-variable-pitch-ui nil
          modus-themes-custom-auto-reload t
          modus-themes-disable-other-themes t

          ;; Options for `modus-themes-prompts' are either nil (the
          ;; default), or a list of properties that may include any of those
          ;; symbols: `italic', `WEIGHT'
          modus-themes-prompts '(italic bold)

          ;; The `modus-themes-completions' is an alist that reads two keys:
          ;; `matches', `selection'. Each accepts a nil value (or empty list) or a
          ;; list of properties that can include any of the following (for WEIGHT
          ;; read further below):
          ;;
          ;; `matches'   :: `underline', `italic', `WEIGHT'
          ;; `selection' :: `underline', `italic', `WEIGHT'
          modus-themes-completions
          '((matches . (extrabold))
            (selection . (semibold italic text-also)))

          modus-themes-org-blocks 'gray-background ; {nil,'gray-background,'tinted-background}

          ;; The `modus-themes-headings' is an alist: read the manual's node about
          ;; it or its doc string. Basically, it supports per-level configurations
          ;; for the optional use of `variable-pitch' typography, a height value
          ;; as a multiple of the base font size (e.g. 1.5), and a `WEIGHT'.
          modus-themes-headings
          '((1 . (variable-pitch 1.5))
            (2 . (1.3))
            (agenda-date . (1.3))
            (agenda-structure . (variable-pitch light 1.8))
            (t . (1.1))))

    ;;; Load Theme and set Toggle
    (load-theme 'modus-operandi)
    (define-key global-map (kbd "<f5>") #'modus-themes-toggle))
#+END_SRC

** Zoom
Zoom using =CTRL= +/-/0.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  (global-set-key (kbd "C-=") (lambda () (interactive) (text-scale-adjust 0)))
#+END_SRC

** Fringes
#+BEGIN_SRC emacs-lisp
  (define-fringe-bitmap '+dot-fringe-bitmap
    (vector #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00011100
            #b00111110
            #b00111110
            #b00111110
            #b00011100
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000))
#+END_SRC

** Line Wrapping
This package provides a mode such that when a paragraph you’re inserting gets
too long, when it wraps round to the next line (assuming truncate-lines is
disabled) sequential lines are indented slightly to distinguish them from other
lines.

#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap
    :custom
    (adaptive-wrap-extra-indent 2)
    :init
    (adaptive-wrap-prefix-mode))
#+END_SRC

* Windows/Buffers
** Windows
*** Winner
#+BEGIN_SRC emacs-lisp
    (use-package winner
      :straight (:type built-in)
      :config
      (winner-mode))
#+END_SRC

*** Perspectives
#+BEGIN_SRC emacs-lisp
  (use-package perspective
    :bind
    ("C-x C-b" . persp-list-buffers)         ; or use a nicer switcher, see below
    :custom
    (persp-sort 'access)
    (persp-mode-prefix-key (kbd "C-c M-p"))  ; pick your own prefix key here
    (persp-state-default-file (file-name-concat +data-dir "perspectives"))
    (persp-save-dir (concat +data-dir "workspaces/"))
    :hook (kill-emacs . persp-state-save)
    :init
    (persp-mode))
#+END_SRC

*** Functions
#+BEGIN_SRC emacs-lisp
  (defun +evil-window-split-follow ()
    "Split current window horizontally and focus new window."
    (interactive)
    (let ((evil-split-window-below (not evil-split-window-below)))
      (call-interactively #'evil-window-split)))

  (defun +evil-window-vsplit-follow ()
    "Split current window vertically and focus new window."
    (interactive)
    (let ((evil-vsplit-window-right (not evil-vsplit-window-right)))
      (call-interactively #'evil-window-vsplit)))
#+END_SRC

*** Rotate
#+BEGIN_SRC emacs-lisp
  (use-package rotate)
#+END_SRC

** Buffers
*** Settings
Now Emacs treats manual buffer switching the same as programmatic switching.
#+BEGIN_SRC emacs-lisp
  (setq switch-to-buffer-obey-display-actions t
        switch-to-buffer-in-dedicated-window 'pop)
#+END_SRC

** Some Musings on Emacs Window Layouts
The following discussion exceeds the needs of documenting Perspective, but it
falls in the category of helping users learn to manage Emacs sessions, and
therefore will likely help potential users of Perspective make the experience
smoother.

Emacs has bad default behavior when it comes to window handling: many commands
and modes have a habit of splitting existing windows and changing the user's
carefully thought-out window layout. This tends to be a more serious problem for
people who run Emacs on large displays (possibly in full-screen mode): the
greater amount of screen real estate makes it easy to split the frame into many
smaller windows, making any unexpected alterations more disruptive.

As a result of indiscriminate-seeming window splits and buffer switching in
existing windows, new Emacs users can get into the habit of expecting Emacs and
its packages to lack basic respect for their layouts. Hence the popularity of
things like `winner-mode`, and packages like
[shackle](https://github.com/wasamasa/shackle).

This may make the value of Perspective seem questionable: why bother with
carefully preserving window layouts if Emacs just throws them away on a `M-x
compile`? The answer is to fix the broken defaults. This is fairly easy:

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'display-buffer-base-action
    '((display-buffer-reuse-window display-buffer-same-window)
      (reusable-frames . t)))

  (customize-set-variable 'even-window-sizes nil)     ; avoid resizing
#+END_SRC

These settings do the following:

1. Tell `display-buffer` to reuse existing windows as much as possible,
   including in other frames. For example, if there is already a `*compilation*`
   buffer in a visible window, switch to that window. This means that Emacs will
   usually switch windows in a "do what I mean" manner for a warmed-up workflow
   (one with, say, a couple of source windows, a compilation output window, and
   a Magit window).
2. Prevent splits by telling `display-buffer` to switch to the target buffer in
   the _current_ window. For example, if there is no `*compilation*` buffer
   visible, then the buffer in whichever window was current when `compile` was
   run will be replaced with `*compilation*`. This may seem intrusive, since it
   changes out the current buffer, but keep in mind that most buffers popped up
   in this manner are easy to dismiss, either with a dedicated keybinding (often
   `q`) or the universally applicable `kill-buffer`. This is easier than
   restoring window arrangements. It is also easier to handle for pre-arranged
   window layouts, since the appropriate command can simply be run in a window
   prepared for it in advance. (If this is a step too far, then replace
   `display-buffer-same-window` with `display-buffer-pop-up-window`.)

** Minibuffer
#+BEGIN_SRC emacs-lisp
  (use-package minibuffer
    :straight (:type built-in)
    :custom
    ;; Allow for minibuffer-ception. Sometimes we need another minibuffer command
    ;; while we're in the minibuffer.
    (enable-recursive-minibuffers t)

    ;; Show current key-sequence in minibuffer ala 'set showcmd' in vim. Any
    ;; feedback after typing is better UX than no feedback at all.
    (echo-keystrokes 0.02)

    ;; Expand the minibuffer to fit multi-line text displayed in the echo-area.
    ;; This doesn't look too great with direnv, however...
    (resize-mini-windows 'grow-only)

    ;; Typing yes/no is obnoxious when y/n will do
    (use-short-answers t)

    ;; Try to keep the cursor out of the read-only portions of the minibuffer.
    (minibuffer-prompt-properties '(read-only t intangible t cursor-intangible t face minibuffer-prompt))

    :init ;; Some more sage advice from the demigods at [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][doom]].
    (defun defer-garbage-collection+ ()
      (setq gc-cons-threshold most-positive-fixnum))

    (defun restore-garbage-collection+ ()
      ;; Deferred so that commands launched immediately after will enjoy the
      ;; benefits.
      (run-at-time
       1 nil (lambda () (setq gc-cons-threshold (* 16 1024 1024))))

      (add-hook 'minibuffer-setup-hook #'defer-garbage-collection+)
      (add-hook 'minibuffer-exit-hook #'restore-garbage-collection+))

    ;; Keep minibuffer out of inaccessible region
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+END_SRC

** Popouts
#+BEGIN_SRC emacs-lisp
  (use-package popper
    :ensure t ; or :straight t
    :bind (("C-`"   . popper-toggle-latest)
           ("M-`"   . popper-cycle)
           ("C-M-`" . popper-toggle-type))
    :init
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "\\*Warnings\\*"
            "\\*xref\\*"
            "\\*Backtrace\\*"
            "*Flymake diagnostics.*"
            "\\*eldoc\\*"
            "\\*compilation\\*"
            "\\*rustic-"
            "^*tex"
            "\\*Ement Notifications\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            "\\*Dtache Shell Command\\*"
            "\\*mu4e-update\\*"
            "\\*GDB.*out\\*"
            help-mode
            compilation-mode))
    (setq popper-display-control 'user)
    (popper-mode +1))
#+END_SRC

* Evil
At some point I got used to =vim= keybindings.
Now, I cannot go back.

** Base
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :straight (evil :type git :host github :repo "emacs-evil/evil")
    :demand t
    :preface
    (setq evil-want-keybinding nil)
    :init
    (evil-mode)
    :custom
    (evil-want-fine-undo t)
    (evil-want-integration t)
    (evil-want-C-g-bindings t)
    (evil-want-C-i-jump nil)
    (evil-want-C-u-scroll t)
    (evil-want-C-u-delete t)
    (evil-want-Y-yank-to-eol t)
    (evil-want-abbrev-expand-on-insert-exit nil)
    (evil-respect-visual-line-mode nil)
    (evil-ex-search-vim-style-regexp t)
    (evil-ex-visual-char-range t)
    (evil-mode-line-format 'nil)
    (evil-symbol-word-search t)
    (evil-default-cursor '+evil-default-cursor-fn)
    (evil-normal-state-cursor 'box)
    (evil-emacs-state-cursor  '(box +evil-emacs-cursor-fn))
    (evil-insert-state-cursor 'bar)
    (evil-visual-state-cursor 'hollow)
    (evil-ex-interactive-search-highlight 'selected-window)
    (evil-kbd-macro-suppress-motion-error t)
    (evil-visual-update-x-selection-p nil)
    :config
    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-set-undo-system 'undo-tree)
    (setq evil-search-module 'evil-search))

  (use-package evil-collection
    :straight (evil-collection :type git :host github :repo "emacs-evil/evil-collection")
    :demand t
    :after evil
    :config
    (evil-collection-init))

  (use-package evil-surround
    :straight (evil-surround :type git :host github :repo "emacs-evil/evil-surround")
    :demand t
    :after evil-collection
    :config
    (global-evil-surround-mode 1))

  (use-package evil-nerd-commenter
    :commands
    (evilnc-comment-operator
     evilnc-inner-comment
     evilnc-outer-commenter)
    :general
    ([remap comment-line] #'evilnc-comment-or-uncomment-lines)
    (:keymaps '(normal visual) "gc" #'evilnc-comment-operator))
#+END_SRC

** Recenter
#+BEGIN_SRC emacs-lisp
  (defun +search-recenter (&rest args)
    "Recenter the current window after a search operation.
  This is a smart recentering command. If you're at the end of a buffer and a
  recentering to the middle ends up showing more trailing (empty) lines then
  it recenters to avoid them. Similar logic is in place for the start of the
  buffer. Otherwise it recenters to the middle."
    (let ((current-line (line-number-at-pos (point)))
          (window-height-2 (/ (window-body-height) 2))
          (first-line (line-number-at-pos (point-min)))
          (last-line (line-number-at-pos (max 0 (- (point-max) 1)))))
      (cl-destructuring-bind (line . recenter-positions)
          (cond ((>= (+ current-line window-height-2) last-line)
                 (cons last-line '(bottom)))
                ((<= (- current-line window-height-2) first-line)
                 (cons first-line '(top)))
                (t (cons nil '(middle))))
        (save-excursion
          (when line
            (goto-line line))
          (recenter-top-bottom)))))

  ;; Advise all search commands to perform a recentering.
  (advice-add 'evil-ex-search-forward  :after #'+search-recenter)
  (advice-add 'evil-ex-search-next     :after #'+search-recenter)
  (advice-add 'evil-ex-search-previous :after #'+search-recenter)
#+END_SRC

* Help
** Which-key
Possibly the greatest package.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init
    (which-key-mode)
    :custom
    (which-key-idle-delay 0.1)
    (which-key-allow-multiple-replacements t)
    (which-key-sort-order #'which-key-key-order-alpha)
    (which-key-sort-uppercase-first nil)
    (which-key-add-column-padding 1)
    (which-key-max-delay-columns nil)
    (which-key-display-lines 6)
    (which-key-side-window-slot -10)
    :config
    (pushnew!
     which-key-replacement-alist
     '(("" . "\\`+?system-packages[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "\\1"))
     '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "\\1"))
     '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "\\1"))))
#+END_SRC

** Helpful
Help me.
#+BEGIN_SRC emacs-lisp
  (use-package help
    :straight (:type built-in)
    :custom
    (help-window-select t)
    (help-enable-variable-value-editing t))
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :commands
    helpful-callable
    helpful-function
    helpful-variable
    helpful-key
    helpful-at-point
    :general
    ([remap describe-callable]    #'helpful-callable)
    ([remap describe-function]    #'helpful-function)
    ([remap describe-variable]    #'helpful-variable)
    ([remap describe-key]         #'helpful-key)
    ([remap view-emacs-debugging] #'helpful-at-point))
#+END_SRC

* Completions
** Basics
*** Prescient
A package for remembering and sorting completion candidates based on frequency
of usage. This is intended to be used with orderless, however because prescient
has its own functions for filtering if orderless is disabled prescient will take
over that as well.

#+BEGIN_SRC emacs-lisp
  (use-package prescient
    :custom
    (prescient-history-length 10000)
    (prescient-save-file (expand-file-name "prescient-history.el" +state-dir))
    (prescient-sort-full-matches-first t) ; Works well with `initialism'.
    (prescient-filter-method '(literal initialism prefix regexp))
    (prescient-use-char-folding t)
    (prescient-use-case-folding 'smart)
    (prescient-sort-length-enable t)
    :config
    (prescient-persist-mode))
#+END_SRC

*** Orderless Style
#+BEGIN_SRC emacs-lisp
(use-package orderless
  :custom
  (completion-styles '(orderless prescient basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles . (partial-completion)))
                   (eglot (styles . (orderless))))))
#+END_SRC

*** Dabbrev
#+BEGIN_SRC emacs-lisp
  (use-package dabbrev
    ;; Other useful Dabbrev configurations.
    :custom
    (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+END_SRC

*** Marginalia
Provide minibuffer annotations.

#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    (marginalia-max-relative-age 0)
    (marginilia-align 'right)
    :init
    (marginalia-mode))
#+END_SRC

*** Icons Completion
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-completion
    :if (display-graphic-p)
    :after
    (marginalia all-the-icons)
    :hook
    (marginalia-mode . all-the-icons-completion-marginalia-setup)
    :init
    (all-the-icons-completion-mode))
#+END_SRC

*** Embark
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
         '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
           nil
           (window-parameters (mode-line-format . none)))))
#+END_SRC

** Vertico
For minibuffer completions.

#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :straight (vertico :files (:defaults "extensions/*")
                       :includes (vertico-multiform))
    :hook (after-init . vertico-mode)
    :bind
    (:map vertico-map
          ("RET" . vertico-directory-enter)
          ("DEL" . vertico-directory-delete-char)
          ("M-DEL" . vertico-directory-delete-word)
          ("C-j" . vertico-next)
          ("C-k" . vertico-previous)
          ("C-f" . vertico-exit)
          :map minibuffer-local-map
          ("M-h" . backward-kill-word))
    :custom
    (vertico-multiform-categories
     '((buffer (vertico-sort-function . copy-sequence))))
    (vertico-preselect 'first)
    (vertico-cycle t)
    (vertico-count 10)
    (vertico-count-format '("%-5s " . "%2$s"))
    (vertico-resize t)


    :config
    ;; Cleans up path when moving directories with shadowed paths syntax, e.g.
    ;; cleans ~/foo/bar/// to /, and ~/foo/bar/~/ to ~/.
    (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)
    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)

    ;; modes
    (vertico-mode)
    (vertico-mouse-mode)
    (vertico-multiform-mode)

    ;; Prefix the current candidate with “» “.
    (defvar +vertico-current-arrow t)

    (cl-defmethod vertico--format-candidate :around
      (cand prefix suffix index start &context ((and +vertico-current-arrow
                                                     (not (bound-and-true-p vertico-flat-mode)))
                                                (eql t)))
      (setq cand (cl-call-next-method cand prefix suffix index start))
      (if (bound-and-true-p vertico-grid-mode)
          (if (= vertico--index index)
              (concat #("▶" 0 1 (face vertico-current)) cand)
            (concat #("_" 0 1 (display " ")) cand))
        (if (= vertico--index index)
            (concat
             #(" " 0 1 (display (left-fringe right-triangle vertico-current)))
             cand)
          cand))))
#+END_SRC

*** Prescient Integration
#+BEGIN_SRC emacs-lisp
  (use-package vertico-prescient
    :config
    (vertico-prescient-mode))
#+END_SRC

** consult
[[https://github.com/minad/consult][consult]] provides search and navigation commands based on the Emacs completion
function [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]]. Completion allows you to quickly select an item from a
list of candidates. Consult offers asynchronous and interactive =consult-grep=
and =consult-ripgrep= commands, and the line-based search command
=consult-line=. Furthermore Consult provides an advanced buffer switching
command =consult-buffer= to switch between buffers, recently opened files,
bookmarks and buffer-like candidates from other sources. Some of the Consult
commands are enhanced versions of built-in Emacs commands. For example the
command =consult-imenu= presents a flat list of the Imenu with [[#live-previews][live preview]],
[[#narrowing-and-grouping][grouping and narrowing]]. Please take a look at the [[#available-commands][full list of commands]].

Consult is fully compatible with completion systems centered around the standard
Emacs =completing-read= API, notably the default completion system, [[https://github.com/minad/vertico][Vertico]],
[[https://github.com/protesilaos/mct][Mct]], and [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html][Icomplete]].

This package keeps the completion system specifics to a minimum. The ability of
the Consult commands to work well with arbitrary completion systems is one of
the main advantages of the package. Consult fits well into existing setups and
it helps you to create a full completion environment out of small and
independent components.

#+begin_src emacs-lisp
  (use-package consult
    :straight (consult :type git :host github :repo "minad/consult")
    :bind (("C-c M-x" . consult-mode-command)
       ("C-c h"   . consult-history)
       ("C-c K"   . consult-kmacro)
       ("C-c i"   . consult-info)
       ([remap Info-search] . consult-info)

       ("C-*"     . consult-org-heading)
       ("C-c e l" . find-library)
       ("C-c e q" . set-variable)
       ("C-c p f" . project-find-file)

       ;; C-x bindings (ctl-x-map)
       ("C-x M-:" . consult-complex-command)
       ("C-x b"   . consult-project-buffer)
       ("C-x B"   . consult-buffer)
       ("C-x 4 b" . consult-buffer-other-window)
       ("C-x 5 b" . consult-buffer-other-frame)
       ("C-x r b" . consult-bookmark)
       ("C-x p b" . consult-project-buffer)
       ;; Other custom bindings
       ("M-y"     . consult-yank-pop)
       ;; M-g bindings (goto-map)
       ("M-g e"   . consult-compile-error)
       ("M-g g"   . consult-goto-line)
       ("M-g M-g" . consult-goto-line)
       ("M-g l"   . consult-goto-line)
       ([remap goto-line] . consult-goto-line)
       ("M-g o"   . consult-org-heading)
       ("M-g m"   . consult-mark)
       ("M-g k"   . consult-global-mark)
       ("M-g i"   . consult-imenu)
       ("M-g I"   . consult-imenu-multi)
       ;; M-s bindings (search-map)
       ("M-s f"   . consult-find)
       ("M-s M-g" . consult-grep)
       ("M-s g"   . consult-git-grep)
       ("M-s r"   . consult-ripgrep)
       ("M-s l"   . consult-line)
       ("M-s L"   . consult-line-multi)
       ("M-s k"   . consult-keep-lines)
       ("M-s u"   . consult-focus-lines)
       ;; Isearch integration
       ("M-s e"   . consult-isearch-history)
       :map isearch-mode-map
       ("M-e"     . consult-isearch-history)
       ("M-s e"   . consult-isearch-history)
       ("M-s l"   . consult-line)
       ("M-s L"   . consult-line-multi)
       ;; Minibuffer history
       :map minibuffer-local-map
       ("M-s"     . consult-history)
       ("M-r"     . consult-history))

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :custom
    (consult-narrow-key "<")
    (consult-async-min-input 1)
    (consult-async-split-style 'semicolon)
    (consult-line-start-from-top t)

    :custom-face
    (consult-file ((t (:inherit font-lock-string-face))))

    :functions
    (consult-register-format
     consult-register-window
     consult-xref)

    ;; The :init configuration is always executed (Not lazy)
    :init
    (with-eval-after-load 'evil
      (evil-global-set-key 'motion "go" #'consult-outline)
      (evil-global-set-key 'motion "gm" #'consult-mark)
      (evil-global-set-key 'motion "gM" #'consult-imenu))

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
      register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
      xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config
    (consult-customize consult--source-buffer :hidden t :default nil)
    (add-to-list 'consult-buffer-sources persp-consult-source)

    (consult-customize
     consult-theme
     :preview-key '(:debounce 0.2 any)
     consult-ripgrep
     consult-git-grep
     consult-grep
     consult-bookmark
     consult-recent-file
     consult-xref
     consult--source-bookmark
     consult--source-file-register
     consult--source-recent-file
     consult--source-project-recent-file
     :preview-key '(:debounce 0.4 any)))
#+end_src

*** consult-dir

[[https://github.com/karthink/consult-dir][consult-dir]] allows you to easily insert directory paths into the minibuffer
prompt in Emacs.

When using the minibuffer, you can switch - with completion and filtering
provided by your completion setup - to any directory you've visited recently, or
to a project, a bookmarked directory or even a remote host via tramp. The
minibuffer prompt will be replaced with the directory you choose.

Why would you want to do this? To avoid “navigating” long distances when picking
a file or directory in any Emacs command that requires one.

Think of it like the shell tools [[https://github.com/wting/autojump][autojump]], [[https://github.com/clvv/fasd][fasd]] or z but for Emacs. See the
demos section below for many more examples. =consult-dir= works with all Emacs
commands that require you to specify file paths, and with [[https://github.com/oantolin/embark][Embark actions]] on
files.

The directory candidates are collected from user bookmarks, Projectile project
roots (if available), project.el project roots (if available) and recentf file
locations. The =default-directory= variable is not changed in the process.

#+begin_src emacs-lisp
  (use-package consult-dir
    :after consult
    :bind (("M-g d"   . consult-dir)
       :map minibuffer-local-completion-map
       ("M-s f" . consult-dir-jump-file)
       ("M-g d" . consult-dir)))
#+end_src

*** consult-git-log-grep
#+begin_src emacs-lisp
  (use-package consult-git-log-grep
    :after consult
    :custom
    (consult-git-log-grep-open-function #'magit-show-commit))
#+end_src

*** consult-eglot
#+begin_src emacs-lisp
  (use-package consult-eglot
    :after (eglot consult)
    :config
    (evil-set-command-property 'consult-eglot :jump t)
    :general
    ([remap xref-find-apropos] #'consult-eglot-symbols))
#+end_src

*** consult-project-extra
=consult-project-extra= defines an endpoint for accessing different sources
related to the common project workflow. Using Consult’s narrowing system, the
user is able to access the current project’s buffers, project files and all the
known projects, in case they want to change projects quickly.
=consult-project-extra= provides an extension to the default Consult
functionality, using the built-in package =project.el=, defining the functions
=consult-project-extra-find= and =consult-project-extra-find-other-window=.
Furthermore, =consult-project-extra= only depends on consult, resulting in a
lean and simple to maintain functionality.

#+BEGIN_SRC emacs-lisp
  (use-package consult-project-extra
    :after consult
    :straight (consult-project-extra :type git :host github :repo "Qkessler/consult-project-extra"))
#+END_SRC

*** kind-icon
#+BEGIN_SRC emacs-lisp
(use-package kind-icon
  :after corfu
  :custom
  (kind-icon-default-face 'corfu-default)
  (kind-icon-use-icons t)
  (kind-icon-blend-background nil)
  (kind-icon-blend-frac 0.08)
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+END_SRC

*** embark-consult
#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :after (embark consult)
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC

** Corfu
[[https://github.com/minad/corfu][corfu]] enhances completion at point with a small completion popup. The current
candidates are shown in a popup below or above the point. Corfu is the
minimalistic =completion-in-region= counterpart of the [[https://github.com/minad/vertico][Vertico]] minibuffer UI.

Corfu is a small package, which relies on the Emacs completion facilities and
concentrates on providing a polished completion UI. Completions are either
provided by commands like =dabbrev-completion= or by pluggable backends (
=completion-at-point-functions=, Capfs). Most programming language major modes
implement a Capf. The Emacs language server clients use Capfs, which retrieve
completions from the server via the language server protocol (LSP). Corfu does
not include its own completion backends. The Emacs built-in Capfs and the Capfs
provided by other programming language packages are usually sufficient. A few
additional Capfs and completion utilities are provided by the [[https://github.com/minad/cape][Cape]] package.

*NOTE*: Corfu uses child frames to show the popup and falls back to the default
setting of the =completion-in-region-function= on non-graphical displays. If you
want to use Corfu in the terminal, install the package [[https://codeberg.org/akib/emacs-corfu-terminal][corfu-terminal]], which
provides an alternative overlay-based display.

#+begin_src emacs-lisp
  (use-package corfu
    :straight (corfu :type git :host github :repo "minad/corfu"
                     :files (:defaults "extensions/*")
                     :includes (corfu-history
                                corfu-popupinfo))
    :bind (("M-/" . completion-at-point)
           :map corfu-map
           ("C-n"      . corfu-next)
           ("C-p"      . corfu-previous)
           ("<escape>" . corfu-quit)
           ("<return>" . corfu-insert)
           ("M-d"      . corfu-info-documentation)
           ("M-l"      . corfu-info-location)
           ("M-."      . corfu-move-to-minibuffer))
    :custom
    ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
    ;; want to perform completion
    (tab-always-indent 'complete)
    (completion-cycle-threshold nil)      ; Always show candidates in menu

    ;; Only use `corfu' when calling `completion-at-point' or
    ;; `indent-for-tab-command'
    (corfu-auto t)
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0.1)

    (corfu-min-width 80)
    (corfu-max-width corfu-min-width)     ; Always have the same width
    (corfu-count 14)
    (corfu-scroll-margin 4)
    (corfu-cycle t)

    ;; `nil' means to ignore `corfu-separator' behavior, that is, use the older
    ;; `corfu-quit-at-boundary' = nil behavior. Set this to separator if using
    ;; `corfu-auto' = `t' workflow (in that case, make sure you also set up
    ;; `corfu-separator' and a keybind for `corfu-insert-separator', which my
    ;; configuration already has pre-prepared). Necessary for manual corfu usage with
    ;; orderless, otherwise first component is ignored, unless `corfu-separator'
    ;; is inserted.
    (corfu-quit-at-boundary nil)
    (corfu-separator ?\s)            ; Use space
    (corfu-quit-no-match 'separator) ; Don't quit if there is `corfu-separator' inserted
    (corfu-preview-current 'insert)  ; Preview first candidate. Insert on input if only one
    (corfu-preselect-first t)        ; Preselect first candidate?

    ;; Other
    (corfu-echo-documentation nil)        ; Already use corfu-popupinfo
    :preface
    (defun corfu-enable-always-in-minibuffer ()
      "Enable Corfu in the minibuffer if Vertico/Mct are not active."
      (unless (or (bound-and-true-p mct--active) ; Useful if I ever use MCT
                  (bound-and-true-p vertico--input))
        (setq-local corfu-auto nil)       ; Ensure auto completion is disabled
        (corfu-mode 1)))

    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let (completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))
    :config
    (global-corfu-mode)
    (corfu-history-mode)
    (with-eval-after-load 'savehist
      (add-to-list 'savehist-additional-variables 'corfu-history))

    ;; In EShell enable some special options.
    (add-hook 'eshell-mode-hook
              (lambda () (setq-local corfu-quit-at-boundary t
                                     corfu-quit-no-match t
                                     corfu-auto nil)
                (corfu-mode)))

    ;; Show some information in eldoc.
    (eldoc-add-command #'corfu-insert)

    ;; Enable Corfu more generally for every minibuffer, as long as no other
    ;; completion UI is active. If you use Mct or Vertico as your main
    ;; minibuffer completion UI. From
    ;; https://github.com/minad/corfu#completing-with-corfu-in-the-minibuffer
    (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1))
#+end_src

*** Prescient Integration
#+BEGIN_SRC emacs-lisp
  (use-package corfu-prescient
    :config
    (corfu-prescient-mode))
#+END_SRC

*** corfu-popupinfo

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :bind (:map corfu-map
              ("M-n" . corfu-popupinfo-scroll-up)
              ("M-p" . corfu-popupinfo-scroll-down)
              ([remap corfu-show-documentation] . corfu-popupinfo-toggle))
  :custom
  (corfu-popupinfo-delay 0.5)
  (corfu-popupinfo-max-width 70)
  (corfu-popupinfo-max-height 20)
  ;; Also here to be extra-safe that this is set when `corfu-popupinfo' is
  ;; loaded. I do not want documentation shown in both the echo area and in
  ;; the `corfu-popupinfo' popup.
  (corfu-echo-documentation nil))
#+end_src

** Cape
[[https://github.com/minad/cape][cape]] provides Completion At Point Extensions which can be used in combination
with the [[https://github.com/minad/corfu][Corfu]] completion UI or the default completion UI. The completion
backends used by =completion-at-point= are so called
=completion-at-point-functions= (Capfs). In principle, the Capfs provided by
Cape can also be used by [[https://github.com/company-mode/company-mode][Company]].

Cape has the super power to transform Company backends into Capfs and merge
multiple Capfs into a Super-Capf! These transformers allow you to still take
advantage of Company backends even if you are not using Company as frontend.

#+begin_src emacs-lisp
(use-package cape
  :demand t
  :bind (("C-c . p" . completion-at-point)
         ("C-c . t" . complete-tag)
         ("C-c . d" . cape-dabbrev)
         ("C-c . h" . cape-history)
         ("C-c . f" . cape-file)
         ("C-c . k" . cape-keyword)
         ("C-c . s" . cape-symbol)
         ("C-c . a" . cape-abbrev)
         ("C-c . l" . cape-line)
         ("C-c . w" . cape-dict)
         ("C-c . \\" . cape-tex)
         ("C-c . _" . cape-tex)
         ("C-c . ^" . cape-tex)
         ("C-c . &" . cape-sgml)
         ("C-c . r" . cape-rfc1345))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-abbrev))
#+end_src

* Projects
** Desktop
#+BEGIN_SRC emacs-lisp
  (use-package desktop
    :straight (:type built-in)
    :custom
    (desktop-path (list +state-dir))
    :config
    ;;(desktop-save-mode)
    )
#+END_SRC

** Project
The built in project management library.

#+BEGIN_SRC emacs-lisp
  (use-package project
    :straight (:type built-in)
    :config
    (defun +project-root (&optional dir)
      (when-let ((project (project-current nil (or dir default-directory))))
        (project-root project)))

    :custom
    (project-list-file (expand-file-name "projects.el" +state-dir))
    (project-vc-extra-root-markers '(".projectile.el" ".project.el" ".project")))
#+END_SRC

* VC
** Basics
Follow symlinks

#+BEGIN_SRC emacs-lisp
  (use-package vc
    :straight (:type built-in)
    :custom
    (vc-command-messages t)
    (vc-follow-symlinks t)
    (vc-allow-async-revert t)
    (vc-handled-backends '(Git))
    (vc-git-diff-switches '("-w" "-U3"))
    (vc-make-backup-files t))
#+END_SRC

** Magit
Possibly the most convincing reason to use EMACS? No, seriously it is awesome!

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :hook
    ((magit-process-mode . goto-address-mode))
    :custom
    ;; Update VC line information
    (auto-revert-check-vc-info t)
    ;; Longer commit lines
    (git-commit-summary-max-length 90)
    (git-commit-style-convention-checks '(overlong-summary-line non-empty-second-line))
    ;; Show more commits
    (magit-log-section-commit-count 25)
    ;; Do not autosave buffers
    (magit-save-repository-buffers nil)
    ;; Go fullscreen
    (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    ;; Restore previous window configuration
    (magit-bury-buffer-function #'magit-restore-window-configuration)
    ;; Set default clone directory
    (magit-clone-default-directory "~/git/")
    ;; Diffing
    ;; Show granular hunks
    (magit-diff-refine-hunk 'all)
    (magit-diff-refine-ignore-whitespace t)
    (magit-diff-paint-whitespace-lines t))
#+END_SRC

*** Transient
#+BEGIN_SRC emacs-lisp
  (use-package transient
    :straight (:type built-in)
    :custom
    ;; Show more transient levels
    (transient-default-level 7)
    ;; Where to save files
    (transient-levels-file (concat +state-dir "transient/levels"))
    (transient-values-file (concat +state-dir "transient/values"))
    (transient-history-file (concat +data-dir "transient/history"))
    :config
    (transient-bind-q-to-quit)
    :general
    (:keymaps 'transient-base-map
              "<escape>" 'transient-quit-one))
#+END_SRC

*** TODO
First, let’s se tup our todo keywords with hl-todo. A good few todo keywords are
already defined in the hl-todo-keyword-faces variable. Why not use them?
hl-todo-mode enables fontlock highlight of these keywords in a buffer. Let’s
enable this mode globally.

 #+BEGIN_SRC emacs-lisp
   (use-package hl-todo
     :init (global-hl-todo-mode 1)
     :general
     (+leader-key
       :packages '(hl-todo)
       :infix "T"
       "" '(:ignore t :wk "TODO")
       "n" #'hl-todo-next
       "p" #'hl-todo-previous))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package magit-todos
    :after (magit hl-todo)
    :custom
    (magit-todos-ignore-case t))
#+END_SRC

*** Gitflow
Gitflow’s framework with Magit with =magit-gitflow=:

#+BEGIN_SRC emacs-lisp
  (use-package magit-gitflow
    :after magit
    :straight (magit-gitflow :build t
                             :type git
                             :host github
                             :repo "jtatarik/magit-gitflow")
    :hook (magit-mode . turn-on-magit-gitflow))
#+END_SRC

*** Forge
Forge acts as an interface for GitHub, Gitlab, and Bitbucket inside Magit. A lot
of possibilities are present, you can read issues and pull requests, create
them, and fork projects among other things.

#+BEGIN_SRC emacs-lisp
  (use-package forge
    :after magit
    :init
    (setq forge-add-default-bindings nil)
    (evil-collection-forge-setup)
    :custom
    (forge-database-file (concat +state-dir "forge/forge-database.sqlite"))
    (forge-owned-accounts '(("f3sch") . nil))
    :general
    (+local-leader-key
      :keymaps 'forge-topic-mode-map
      "c"  #'forge-create-post
      "e"  '(:ignore t :which-key "edit")
      "ea" #'forge-edit-topic-assignees
      "ed" #'forge-edit-topic-draft
      "ek" #'forge-delete-comment
      "el" #'forge-edit-topic-labels
      "em" #'forge-edit-topic-marks
      "eM" #'forge-merge
      "en" #'forge-edit-topic-note
      "ep" #'forge-edit-post
      "er" #'forge-edit-topic-review-requests
      "es" #'forge-edit-topic-state
      "et" #'forge-edit-topic-title))
#+END_SRC

** Git Gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :custom
    (git-gutter:hide-gutter t)
    (git-gutter:update-interval 60)
    :config
    (add-to-list 'git-gutter:update-hooks 'focus-in-hook)
    (global-git-gutter-mode t))

  (use-package git-gutter-fringe
    :after git-gutter
    :config
    (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+END_SRC

** EDiff
Visual diff interface

#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :straight (:type built-in)
    ;; Restore window config after quitting ediff
    :hook ((ediff-before-setup . ediff-save-window-conf)
           (ediff-quit         . ediff-restore-window-conf))
    :config
    (defvar local-ediff-saved-window-conf nil)

    (defun ediff-save-window-conf ()
      (setq local-ediff-saved-window-conf (current-window-configuration)))

    (defun ediff-restore-window-conf ()
      (when (window-configuration-p local-ediff-saved-window-conf)
        (set-window-configuration local-ediff-saved-window-conf)))
    :custom
    (ediff-highlight-all-diffs t)
    (ediff-window-setup-function 'ediff-setup-windows-plain)
    (ediff-split-window-function 'split-window-horizontally)
    (ediff-merge-split-window-function 'split-window-horizontally))
#+END_SRC

** Git Config Modes
#+BEGIN_SRC emacs-lisp
  (use-package git-modes)
#+END_SRC

** Smerge
#+BEGIN_SRC emacs-lisp
  (use-package smerge-mode
    :straight (:type built-in)
    :diminish smerge-mode
    :init
    (defhydra hydra-smerge-mode (:hint nil
                                       :pre (if (not smerge-mode) (smerge-mode 1))
                                       ;; Disable `smerge-mode' when quitting hydra if
                                       ;; no merge conflicts remain.
                                       :post (smerge-auto-leave))
              "
                                                           [smerge]
    Movement   Keep           Diff              Other
    ╭─────────────────────────────────────────────────────────╯
       ^_g_^       [_b_] base       [_<_] upper/base    [_C_] Combine
       ^_C-k_^     [_u_] upper      [_=_] upper/lower   [_r_] resolve
       ^_k_ ↑^     [_l_] lower      [_>_] base/lower    [_R_] remove
       ^_j_ ↓^     [_a_] all        [_H_] hightlight
       ^_C-j_^     [_RET_] current  [_E_] ediff                 ╭──────────
       ^_G_^                                                │ [_q_] quit
  "
              ("g" (progn (goto-char (point-min)) (smerge-next)))
              ("G" (progn (goto-char (point-max)) (smerge-prev)))
              ("C-j" smerge-next)
              ("C-k" smerge-prev)
              ("j" next-line)
              ("k" previous-line)
              ("b" smerge-keep-base)
              ("u" smerge-keep-upper)
              ("l" smerge-keep-lower)
              ("a" smerge-keep-all)
              ("RET" smerge-keep-current)
              ("\C-m" smerge-keep-current)
              ("<" smerge-diff-base-upper)
              ("=" smerge-diff-upper-lower)
              (">" smerge-diff-base-lower)
              ("H" smerge-refine)
              ("E" smerge-ediff)
              ("C" smerge-combine-with-next)
              ("r" smerge-resolve)
              ("R" smerge-kill-current)
              ("q" nil :color blue))
    :hook (find-file . (lambda ()
                         (save-excursion
                           (goto-char (point-min))
                           (when (re-search-forward "^<<<<<<< " nil t)
                             (hydra-smerge-mode/body))))))
#+END_SRC

* Undo
Few understand emacs' kill ring, me included.
Hence Something visually appealing.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :defer t
    :init
    (progn
      (setq undo-tree-visualizer-timestamps t
            undo-tree-visualizer-diff t
            ;; See `vim-style-enable-undo-region'.
            undo-tree-enable-undo-in-region t
            undo-tree-auto-save-history t
            ;; 10X bump of the undo limits to avoid issues with premature Emacs GC
            ;; which truncages the undo history aggresively
            undo-limit 800000
            undo-strong-limit 12000000
            undo-outer-limit 120000000
            undo-tree-history-directory-alist
            `(("." . ,(let ((dir (expand-file-name "undo-tree-history" +cache-dir)))
                        (if (file-exists-p dir)
                            (unless (file-accessible-directory-p dir)
                              (warn "Cannot access directory `%s'.
   Perhaps you don't have required permissions, or it's not a directory.
   See variable `undo-tree-history-directory-alist'." dir))
                          (make-directory dir))
                        dir))))
      (global-undo-tree-mode))
    :config
    ;; Compress undo-tree history files with zstd, if available. File size isn't
    ;; the (only) concern here: the file IO barrier is slow for Emacs to cross;
    ;; reading a tiny file and piping it in-memory through zstd is *slightly*
    ;; faster than Emacs reading the entire undo-tree file from the get go (on
    ;; SSDs). Whether or not that's true in practice, we still enjoy zstd's ~80%
    ;; file savings (these files add up over time and zstd is so incredibly fast).
    (when (executable-find "zstd")
      (defadvice! +undo--append-zst-extension-to-file-name-a (file)
        :filter-return #'undo-tree-make-history-save-file-name
        (concat file ".zst")))

    ;; Strip text properties from undo-tree data to stave off bloat. File size
    ;; isn't the concern here; undo cache files bloat easily, which can cause
    ;; freezing, crashes, GC-induced stuttering or delays when opening files.
    (defadvice! +undo--strip-text-properties-a (&rest _)
      :before #'undo-list-transfer-to-tree
      (dolist (item buffer-undo-list)
        (and (consp item)
             (stringp (car item))
             (setcar item (substring-no-properties (car item))))))

    ;; Undo-tree is too chatty about saving its history files. This doesn't
    ;; totally suppress it logging to *Messages*, it only stops it from appearing
    ;; in the echo-area.
    (advice-add #'undo-tree-save-history :around #'doom-shut-up-a))
#+END_SRC

* Org
** Base
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight (:type built-in)
    :config
    (setq
     ;; Edit settings
     org-auto-align-tags nil
     org-tags-column 0
     org-catch-invisible-edits 'show-and-error
     org-special-ctrl-a/e t
     org-insert-heading-respect-content t

     ;; Org styling, hide markup etc.
     org-hide-emphasis-markers t
     org-pretty-entities t
     org-ellipsis "…"))
#+END_SRC

** Modern Look
#+BEGIN_SRC emacs-lisp
  (use-package org-modern
    :config
    (global-org-modern-mode))
#+END_SRC

** Shortcuts
*** Fast SRC_BLOCK
#+BEGIN_SRC emacs-lisp
  (defun org-insert-src-block (src-code-type)
    "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
    (interactive (let ((src-code-types '("emacs-lisp" "python" "C" "sh" "java" "js"
                     "clojure" "C++" "css" "calc" "asymptote" "dot" "gnuplot" "ledger"
                     "lilypond" "mscgen" "octave" "oz" "plantuml" "R" "sass" "screen" "sql"
                     "awk" "ditaa" "haskell" "latex" "lisp" "matlab" "ocaml" "org" "perl"
                     "ruby" "scheme" "sqlite")))
           (list (ido-completing-read "Source code type: " src-code-types))))
    (progn (insert (format "#+BEGIN_SRC %s\n" src-code-type))
       (insert "#+END_SRC\n") (previous-line 2) (org-edit-src-code)))

  (add-hook 'org-mode-hook #'(lambda () ;; keybinding for editing source code blocks
                   (local-set-key (kbd "C-c i e") 'org-edit-src-code) ;; keybinding for inserting code blocks
                   (local-set-key (kbd "C-c i s")
  'org-insert-src-block)))
#+END_SRC

* Programming
#+BEGIN_SRC emacs-lisp
  (use-package prog-mode
    :straight (:type built-in)
    :config
    (global-prettify-symbols-mode +1)
    (setq prettify-symbols-unprettify-at-point 'right-edge
          next-error-message-highlight t
          show-paren-context-when-offscreen 'child-frame)
    (add-hook 'prog-mode 'show-paren-mode))
#+END_SRC

** LSP
#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :straight (:type built-in)
    :hook ((prog-mode . eglot-ensure)
           (eglot-managed-mode . eglot-inlay-hints-mode))
    :custom
    (eglot-autoshutdown t)
    (eglot-autoreconnect 3)
    (eglot-sync-connect 1)
    (eglot-extend-to-xref t)
    (eglot-connect-timeout 10)
    (eglot-send-changes-idle-time 0.5)
    :config
    (add-to-list 'eglot-stay-out-of 'eldoc-documentation-strategy)

  ;;; C/C++
    (add-to-list 'eglot-server-programs
                 '((c-ts-mode c++-ts-mode c-mode c++-mode)
                   . ("clangd"
                      "-j=2"
                      ;; "--offset-encoding=utf-8"
                      "--header-insertion=never"
                      "--header-insertion-decorators=0"
                      "--completion-style=detailed"
                      "--completion-parse=auto"
                      "--all-scopes-completion"
                      "--cross-file-rename"
                      "--log=error"
                      "--malloc-trim"
                      "--background-index"
                      "--background-index-priority=low"
                      "--pch-storage=memory"
                      "--clang-tidy"))))
#+END_SRC

** Treesitter
The future.

#+BEGIN_SRC emacs-lisp
  (use-package treesit
    :straight (:type built-in)
    :custom
    (treesit-font-lock-level 4))

  (use-package treesit-auto
    :straight (:host github :repo "renzmann/treesit-auto")
    :hook (after-init . global-treesit-auto-mode)
    :commands treesit-auto-install-all
    :custom
    (treesit-auto-install t)
    :config
    (setq treesit-language-source-alist (treesit-auto--build-treesit-source-alist))
    (+register-build-function #'treesit-auto-install-all))
#+END_SRC

** Formatting
#+BEGIN_SRC emacs-lisp
  (use-package apheleia
    :straight (apheleia :type git :host github :repo "radian-software/apheleia")
    :custom
    (apheleia-hide-log-buffers t)
    (apheleia-remote-alogrithm 'remote)
    :config
    ;; Also enable lisp indentation in emacs-lisp
    (dolist (alist '((lisp-data-mode . lisp-indent)
                     (emacs-lisp-mode . lisp-indent)
                     (sh-mode . shfmt)))
      (push 'apheleia-mode-alist alist))
    ;; Enable the global mode
    (apheleia-global-mode))
#+END_SRC

** Smartparens
Giving parenthesis some brains.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :after evil
    :custom
    ;; Overlays are too distracting and not terribly helpful. `show-paren-mode' does
    ;; this for us already (and is faster), so...
    (sp-highlight-pair-overlay nil)
    (sp-highlight-wrap-overlay nil)
    (sp-highlight-wrap-tag-and-overlay nil)
    ;; The default is 100, because smartparen's scans are relatively expensive
    ;; (especially with large pair lists for some modes), we reduce it, as a
    ;; better compromise between performance and accuracy.
    (sp-max-prefix-length 25)
    ;; No pair has any business being longer than 4 characters; if they must, set
    ;; it buffer-locally. It's less work for smartparens.
    (sp-max-pair-length 4)
    ;; ...and stay highlighted until we've truly escaped the pair!
    (sp-cancel-autoskip-on-backward-movement nil)
    ;; But if someone does want overlays enabled, evil users will be stricken
    ;; with an off-by-one issue where smartparens assumes you're outside the
    ;; pair when you're really at the last character in insert mode. We must
    ;; correct this vile injustice.
    (sp-show-pair-from-inside t)
    :config
    (require 'smartparens-config)
    ;; Enable Smartparens functionality in all buffers.
    (smartparens-global-mode +1)
    ;; Set up keybindings for s-expression navigation and manipulation
    ;; in the style of Paredit.
    (sp-use-paredit-bindings)
    ;; Highlight matching delimiters.
    (show-smartparens-global-mode +1))
#+END_SRC

** Rainbow Delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode)
    :commands rainbow-delimiters-mode)
#+END_SRC

** Code
*** Assembly
#+BEGIN_SRC emacs-lisp
  (use-package asm-mode
    :straight (:type built-in)
    :hook (asm-mode . indent-tabs-mode)
    :mode (rx "." (or "asl" "S" "s") eol))
#+END_SRC

*** AWK
#+BEGIN_SRC emacs-lisp
  (use-package awk
    :straight (:type built-in)
    :interpreter "gawk"
    :hook (awk-mode . +flylint)

    :preface
    (defun awk-mode-reset-electric-pair+ ()
      (setq-local electric-pair-inhibit-predicate
                  #'electric-pair-default-inhibit))
    :hook (awk-mode . awk-mode-reset-electric-pair+))
#+END_SRC

*** ELisp
**** Pretty Print
#+BEGIN_SRC emacs-lisp
  (use-package pp
    :general
    (+local-leader-key
      :keymaps 'emacs-lisp-mode-map
      "eM" 'pp-macroexpand-expression
      "em" 'pp-macroexpand-last-sexp
      "ex" 'pp-eval-last-sexp
      "eX" 'pp-eval-expression))
#+END_SRC

**** Parinfer
#+BEGIN_SRC emacs-lisp
  (use-package parinfer-rust-mode
    :disabled t
    :hook emacs-lisp-mode common-lisp-mode scheme-mode
    :init
    (setq parinfer-rust-auto-download     t
          parinfer-rust-library-directory (expand-file-name "parinfer-rust/" +data-dir))
    (add-hook 'parinfer-rust-mode-hook
              (lambda () (smartparens-mode -1)))
    (add-hook 'org-mode-hook (lambda () (parinfer-rust-mode -1)))
    :general
    (+local-leader-key
      :keymaps 'parinfer-rust-mode-map
      "m" #'parinfer-rust-switch-mode
      "M" #'parinfer-rust-toggle-disable))
#+END_SRC

**** Checkdoc
Feature `checkdoc' provides some tools for validating Elisp docstrings against
common conventions.

#+BEGIN_SRC emacs-lisp
  (use-package checkdoc
    :straight (:type built-in)
    :init
    ;; Not sure why this isn't included by default.
    (put 'checkdoc-package-keywords-flag 'safe-local-variable #'booleanp))
#+END_SRC

*** C/C++
#+BEGIN_SRC emacs-lisp
  (use-package cc-mode
    :straight (:type built-in)
    :custom
    (c-default-style '((java-mode . "linux")
                       (awk-mode . "awk")
                       (other . "linux"))))
#+END_SRC

#+Begin_SRC emacs-lisp
    (use-package c-ts-mode
      :straight (:type built-in)
      :custom
      (c-ts-mode-indent-style 'linux))
#+END_SRC

**** CMake
#+BEGIN_SRC emacs-lisp
  (use-package cmake-mode
    :mode (rx (or (and "CMakeLists.txt" eol) ".cmake")))

  (use-package cmake-font-lock
    :straight (:host github :repo "Lindydancer/cmake-font-lock" :files (:defaults "*"))
    :hook (cmake-mode . cmake-font-lock-activate))

  (use-package cmake-ts-mode
    :mode (rx (or (and "CMakeLists.txt" eol) ".cmake")))
#+END_SRC

*** Markdown
#+BEGIN_SRC emacs-lisp
  ;; The markdown mode is awesome! unbeatable
  (use-package markdown-mode
    :init
    (advice-add #'markdown--command-map-prompt :override #'ignore)
    (advice-add #'markdown--style-map-prompt   :override #'ignore)
    :mode ("README\\(?:\\.md\\)?\\'" . gfm-mode)
    :hook (markdown-mode . visual-line-mode)
    :bind (:map markdown-mode-style-map
                ("r" . markdown-insert-ruby-tag)
                ("d" . markdown-insert-details))
    :config
    (defun markdown-insert-ruby-tag (text ruby)
      "Insert ruby tag with `TEXT' and `RUBY' quickly."
      (interactive "sText: \nsRuby: \n")
      (insert (format "<ruby>%s<rp>(</rp><rt>%s</rt><rp>)</rp></ruby>" text ruby)))

    (defun markdown-insert-details (title)
      "Insert details tag (collapsible) quickly."
      (interactive "sTitle: ")
      (insert (format "<details><summary>%s</summary>\n\n</details>" title)))
    :custom
    (markdown-header-scaling t)
    (markdown-enable-wiki-links t)
    (markdown-italic-underscore t)
    (markdown-asymmetric-header t)
    (markdown-gfm-uppercase-checkbox t)
    (markdown-fontify-code-blocks-natively t))

  ;; Pixel alignment for org/markdown tables
  (use-package valign
    :hook ((markdown-mode org-mode) . valign-mode))
#+END_SRC

*** XML
#+BEGIN_SRC emacs-lisp
  (use-package nxml-mode
    :straight (:type built-in)
    :mode (("\\.xml\\'" . nxml-mode)
           ("\\.rss\\'" . nxml-mode))
    :custom
    (nxml-slash-auto-complete-flag t)
    (nxml-auto-insert-xml-declaration-flag t))
#+END_SRC

*** YAML
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode ("\\.ya?ml\\'" . yaml-mode))
#+END_SRC

** Debug
*** GDB
#+BEGIN_SRC emacs-lisp
  (use-package gdb-mi
    :straight (:type built-in)
    :custom
    (gdb-mi-decode-strings 'utf-8)
    (gdb-show-main t)
    (gdb-debug-log-max 1024)
    (gdb-restore-window-configuration-after-quit t)
    (gdb-window-configuration-directory (expand-file-name "gdb" +data-dir))
    (gdb-thread-buffer-verbose-names nil)
    (gdb-display-io-nopopup t)
    (gdb-show-changed-values t)
    (gdb-delete-out-of-scope t)
    (gdb-use-colon-colon-notation t)
    (gdb-many-windows t))
#+END_SRC

* EMail
#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :commands mu4e mu4e-compose-new
    :init
    (let ((mu4e-path "/usr/local/share/emacs/site-lisp/mu/mu4e"))
      (when (file-directory-p mu4e-path)
        (add-to-list 'load-path mu4e-path)))
    :config
    ;; use mu4e for e-mail in emacs
    (setq mail-user-agent 'mu4e-user-agent)

    (defvar +mu4e-header-colorized-faces
      '(all-the-icons-green
        all-the-icons-lblue
        all-the-icons-purple-alt
        all-the-icons-blue-alt
        all-the-icons-purple
        all-the-icons-yellow)
      "Faces to use when coloring folders and account stripes.")

    (defun +mu4e--str-color-face (str &optional offset)
      "Select a face from `+mu4e-header-colorized-faces' based on
  STR and any integer OFFSET."
      (let* ((str-sum (apply #'+ (mapcar (lambda (c) (% c 3)) str)))
             (color (nth (% (+ str-sum (if offset offset 0))
                            (length +mu4e-header-colorized-faces))
                         +mu4e-header-colorized-faces)))
        color))

    (defun +mu4e-colorize-str (str &optional unique herring)
      "Apply a face from `+mu4e-header-colorized-faces' to STR.
  If HERRING is set, it will be used to determine the face instead of STR.
  Will try to make unique when non-nil UNIQUE,
  a quoted symbol for a alist of current strings and faces provided."
      (unless herring
        (setq herring str))
      (put-text-property
       0 (length str)
       'face
       (list
        (if (not unique)
            (+mu4e--str-color-face herring str)
          (let ((unique-alist (eval unique)))
            (unless (assoc herring unique-alist)
              (if (> (length unique-alist) (length +mu4e-header-colorized-faces))
                  (push (cons herring (+mu4e--str-color-face herring)) unique-alist)
                (let ((offset 0) color color?)
                  (while (not color)
                    (setq color? (+mu4e--str-color-face herring offset))
                    (if (not (rassoc color? unique-alist))
                        (setq color color?)
                      (setq offset (1+ offset))
                      (when (> offset (length +mu4e-header-colorized-faces))
                        (message "Warning: +mu4e-colorize-str was called with non-unique-alist UNIQUE-alist alist.")
                        (setq color (+mu4e--str-color-face herring)))))
                  (push (cons herring color) unique-alist)))
              (set unique unique-alist))
            (cdr (assoc herring unique-alist))))
        'default)
       str)
      str)

    ;; Add a column to display what email account the email belongs to,
    ;; and an account color stripe column
    (defvar +mu4e-header--maildir-colors nil)
    (add-to-list 'mu4e-header-info-custom
                 '(:account .
                            (:name "Account"
                                   :shortname "Account"
                                   :help "Which account/maildir this email belongs to"
                                   :function
                                   (lambda (msg)
                                     (let ((maildir (replace-regexp-in-string
                                                     "\\`/?\\([^/]+\\)/.*\\'" "\\1"
                                                     (mu4e-message-field msg :maildir))))
                                       (+mu4e-colorize-str
                                        (replace-regexp-in-string
                                         "^gmail"
                                         (propertize "g" 'face 'bold-italic)
                                         maildir)
                                        '+mu4e-header--maildir-colors
                                        maildir))))))
    (add-to-list 'mu4e-header-info-custom
                 '(:account-stripe .
                                   (:name "Account"
                                          :shortname "▐"
                                          :help "Which account/maildir this email belongs to"
                                          :function
                                          (lambda (msg)
                                            (let ((account
                                                   (replace-regexp-in-string
                                                    "\\`/?\\([^/]+\\)/.*\\'" "\\1"
                                                    (mu4e-message-field msg :maildir))))
                                              (propertize
                                               (+mu4e-colorize-str "▌" '+mu4e-header--maildir-colors account)
                                               'help-echo account))))))

    ;; the headers to show in the headers list -- a pair of a field
    ;; and its width, with `nil' meaning 'unlimited'
    ;; better only use that for the last field.
    ;; These are the defaults:
    (setq mu4e-headers-fields
          '((:account-stripe . 1)
            (:flags . 12)
            (:from-or-to . 25)
            (:human-date . 8)
            (:recipnum . 2)
            (:subject . 100))
          mu4e-headers-date-format "%d/%m/%y"
          mu4e-headers-time-format "⧖ %H:%M"
          mu4e-headers-results-limit 1000
          )

    (setq mu4e-headers-auto-update t
          mu4e-get-mail-command "mbsync --all --config ~/.config/mbsync/config"
          mu4e-update-interval 300
          mu4e-alert-max-messages-to-process 1000


          mu4e-eldoc-support t
          mu4e-attachment-dir "~/Downloads"
          mu4e-completing-read-function 'completing-read
          mu4e-index-cleanup t ;; do a full cleanup check
          mu4e-index-lazy-check t ;; dont consider up-to-date dirs
          mu4e-index-update-error-warning nil ;; mbsync exists with 1 due to unknown flags on far
          mu4e-hide-index-messages t ;; do not show any messages
          mu4e-headers-leave-behavior 'apply
          mu4e-view-show-images t
          mu4e-view-image-max-width 400
          mu4e-headers-skip-duplicates t)

    (setq sendmail-program (executable-find "msmtp")
          send-mail-function #'message-send-mail-with-sendmail
          message-sendmail-f-is-evil t
          message-sendmail-extra-arguments '("--read-envelope-from" "--file=/home/f3sch/.config/msmtp/config")
          message-send-mail-function #'message-send-mail-with-sendmail)

    (setq message-cite-reply-position 'below ;; never top post!
          message-kill-buffer-on-exit t)

    ;; Search like GMail
    (setq mu4e-search-include-related t
          mu4e-search-skip-duplicates t)

    (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))

    (setq mu4e-bookmarks
          '((:name "Inbox - CERN" :query "maildir:/cern/INBOX" :key ?c)
            (:name "Inbox - Git" :query "maildir:/git/INBOX AND NOT AND NOT list:bug-gnu-emacs.gnu.org AND NOT list:emacs-devel.gnu.org AND NOT list:help-gnu-emacs.gnu.org AND NOT to:doomemacs@noreply.github.com AND NOT to:AliceO2@noreply.github.com" :key ?g)
            (:name "Inbox - Web" :query "maildir:/web/INBOX or maildir:/web/Unerw&APw-nscht" :key ?w)
            (:name "Inbox - Uni" :query "maildir:/uni/INBOX" :key ?u)
            (:name "Unread Messages" :query "flag:unread AND NOT flag:thrashed" :key ?U)
            ;; (:name "Linux - Kernel" :query "list:linux-kernel.vger.kernel.org" :key ?K)
            ;; (:name "Linux - Staging" :query "list:linux-staging.lists.linux.dev" :key ?S)
            ;; (:name "Linux - Newbies" :query "list:kernelnewbies.kernelnewbies.org" :key ?N)
            (:name "Emacs - Devel" :query "list:emacs-devel.gnu.org" :key ?E)
            (:name "Emacs - Help" :query "list:help-gnu-emacs.gnu.org" :key ?H)
            (:name "Emacs - Bug" :query "list:bug-gnu-emacs.gnu.org" :key ?B)
            (:name "Alice - O2" :query "to:AliceO2@noreply.github.com" :key ?A)))

    ;; Adding to the known mailing lists.
    (setq mu4e-user-mailing-lists
          '(("linux-kernel.vger.kernel.org" . "Linux Kernel")
            ("kernelnewbies.kernelnewbies.org" . "Linux Newbies")
            ("help-gnu-emacs.gnu.org" . "Emacs Help")
            ("bug-gnu-emacs.gnu.org" . "Emacs Bugs")
            ("emacs-devel.gnu.org" . "Emacs Devel")))

    ;; I want to sign my mail.
    (add-hook 'mu4e-compose-mode-hook 'mml-secure-message-sign)
    (epa-global-mail-mode)

    ;; Do not send to these addresses in wide reply.
    (setq mu4e-compose-reply-ignore-address
          '("notifications@github\\.com"
            ".*@noreply\\.github\\.com"))

    (setq mu4e-contexts
          `( ,(make-mu4e-context
               :name "WEB"
               :enter-func (lambda () (mu4e-message "Entering WEB context"))
               :leave-func (lambda () (mu4e-message "Leaving WEB context"))
               ;; we match based on the contact-fields of the message
               :match-func (lambda (msg)
                             (when msg
                               (mu4e-message-contact-field-matches msg
                                                                   :to "felix.schlepper@web.de")))
               :vars '( ( user-mail-address . "felix.schlepper@web.de"  )
                        ( smtpmail-smtp-user . "felix.schlepper@web.de")
                        ( user-full-name . "Felix Schlepper" )
                        ( message-user-organization . "Private" )
                        ( mu4e-sent-folder . "/web/Sent")
                        ( mu4e-drafts-folder . "/web/Entwurf")
                        ( mu4e-trash-folder . "/web/Trash")
                        ( mu4e-refile-folder . "/web/INBOX")
                        ( mu4e-maildir-shortcuts . (
                                                    ("/web/INBOX" . ?i)
                                                    ("/web/Trash" . ?t)
                                                    ("/web/Sent" . ?S)
                                                    ("/web/Unerw&APw-nscht" . ?s)
                                                    ("/web/Unbekannt" . ?u)))
                        ( mu4e-compose-signature .
                          (concat
                           "Viele Gruesse\n"
                           "Felix\n"
                           "(GPG: 0x997C87E6BE5239F0)"))))
             ,(make-mu4e-context
               :name "UNI"
               :enter-func (lambda () (mu4e-message "Entering UNI context"))
               :leave-func (lambda () (mu4e-message "Leaving UNI context"))
               ;; we match based on the contact-fields of the message
               :match-func (lambda (msg)
                             (when msg
                               (mu4e-message-contact-field-matches msg
                                                                   :to "schlepper@stud.uni-heidelberg.de")))
               :vars '( ( user-mail-address . "schlepper@stud.uni-heidelberg.de"  )
                        ( smtpmail-smtp-user . "schlepper@stud.uni-heidelberg.de")
                        ( user-full-name . "Felix Schlepper" )
                        ( message-user-organization . "UNI" )
                        ( mu4e-sent-folder . "/uni/Sent")
                        ( mu4e-drafts-folder . "/uni/Drafts")
                        ( mu4e-trash-folder . "/uni/Trash")
                        ( mu4e-refile-folder . "/uni/INBOX")
                        ( mu4e-maildir-shortcuts . (
                                                    ("/uni/INBOX" . ?i)
                                                    ("/uni/Trash" . ?t)
                                                    ("/uni/Sent" . ?S)))
                        ( mu4e-compose-signature .
                          (concat
                           "Cheers\n"
                           "Felix\n"
                           "(GPG: 0x997C87E6BE5239F0)"))))
             ,(make-mu4e-context
               :name "GIT"
               :enter-func (lambda () (mu4e-message "Entering GIT context"))
               :leave-func (lambda () (mu4e-message "Leaving GIT context"))
               ;; we match based on the contact-fields of the message
               :match-func (lambda (msg)
                             (when msg
                               (mu4e-message-contact-field-matches msg
                                                                   :to "f3sch.git@outlook.com")))
               :vars '( ( user-mail-address . "f3sch.git@outlook.com"  )
                        ( smtpmail-smtp-user . "f3sch.git@outlook.com")
                        ( user-full-name . "Felix Schlepper" )
                        ( message-user-organization . "Git" )
                        ( mu4e-sent-folder . "/git/Sent")
                        ( mu4e-drafts-folder . "/git/Drafts")
                        ( mu4e-trash-folder . "/git/Deleted")
                        ( mu4e-refile-folder . "/git/INBOX")
                        ( mu4e-maildir-shortcuts . (
                                                    ("/git/INBOX" . ?i)
                                                    ("/git/Deleted" . ?t)
                                                    ("/git/Sent" . ?S)
                                                    ("/git/Junk" . ?s)
                                                    ("/git/Archive" . ?a)
                                                    ("/git/Notes" . ?n)
                                                    ("/git/Outbox" . ?o)
                                                    ("/git/Kernelnewbies" . ?k)))
                        ( mu4e-compose-signature .
                          (concat
                           "Cheers\n"
                           "Felix\n"
                           "(GPG: 0x997C87E6BE5239F0)"))))
             ,(make-mu4e-context
               :name "CERN"
               :enter-func (lambda () (mu4e-message "Entering CERN context"))
               :leave-func (lambda () (mu4e-message "Leaving CERN context"))
               ;; we match based on the contact-fields of the message
               :match-func (lambda (msg)
                             (when msg
                               (mu4e-message-contact-field-matches msg
                                                                   :to "felix.schlepper@cern.ch")))
               :vars '( ( user-mail-address . "felix.schlepper@cern.ch"  )
                        ( smtpmail-smtp-user . "felix.schlepper@cern.ch")
                        ( user-full-name . "Felix Schlepper" )
                        ( message-user-organization . "CERN" )
                        ( mu4e-sent-folder . "/cern/Sent Items")
                        ( mu4e-drafts-folder . "/cern/Drafts")
                        ( mu4e-trash-folder . "/cern/Deleted Items")
                        ( mu4e-refile-folder . "/cern/INBOX")
                        ( mu4e-maildir-shortcuts . (
                                                    ("/git/INBOX" . ?i)
                                                    ("/git/Deleted Items" . ?t)
                                                    ("/git/Sent Items" . ?s)))
                        ( mu4e-compose-signature .
                          (concat
                           "Cheers\n"
                           "Felix\n"
                           "(GPG: 0x997C87E6BE5239F0)"))))))


    ;; set `mu4e-context-policy` and `mu4e-compose-policy` to tweak when
    ;; mu4e should guess or ask the correct context, e.g.

    ;; start with the first (default) context; default is to ask-if-none
    ;; (ask when there's no context yet, and none match)
    (setq mu4e-context-policy 'pick-first)

    ;; compose with the current context is no context matches; default
    ;; is to ask
    (setq mu4e-compose-context-policy nil)

    ;;; Actions
    (require 'mu4e-actions)
    (defun +mu4e-view-save-all-attachments (&optional msg)
      "Save all MIME parts from current mu4e gnus view buffer."
      ;; Copied from mu4e-view-save-attachments
      (interactive "P")
      (if (and (eq major-mode 'mu4e-view-mode)
               (derived-mode-p 'gnus-article-mode))
          (let* ((msg (or msg (mu4e-message-at-point)))
                 (id (+clean-file-name (mu4e-message-field msg :subject) :downcase))
                 (attachdir (expand-file-name id mu4e-attachment-dir))
                 (parts (mu4e~view-gather-mime-parts))
                 (handles '())
                 (files '())
                 dir)
            (mkdir attachdir t)
            (dolist (part parts)
              (let ((fname (or (cdr (assoc 'filename (assoc "attachment" (cdr part))))
                               (seq-find #'stringp
                                         (mapcar (lambda (item) (cdr (assoc 'name item)))
                                                 (seq-filter 'listp (cdr part)))))))
                (when fname
                  (push `(,fname . ,(cdr part)) handles)
                  (push fname files))))
            (if files
                (progn
                  (setq dir
                        (if current-prefix-arg (read-directory-name "Save to directory: ")
                          attachdir))
                  (cl-loop for (f . h) in handles
                           when (member f files)
                           do (mm-save-part-to-file h
                                                    (+file-name-incremental
                                                     (expand-file-name f dir)))))
              (mu4e-message "No attached files found")))
        (mu4e-error "Not in `mu4e-view-mode' nor in `gnus-article-mode'.")))

    ;; View
    (appendq! mu4e-view-actions
              '(("Apply git patches" . mu4e-action-git-apply-patch)
                ("Mapply git am patch" . mu4e-action-git-apply-mbox)
                ("save all attachments" . +mu4e-view-save-all-attachments)
                ("ViewInBrowser" . mu4e-action-view-in-browser)))
    ;; Header
    (appendq! mu4e-headers-actions
              '(("Apply git patches" . mu4e-action-git-apply-patch)
                ("Mapply git am patch" . mu4e-action-git-apply-mbox)))



    ;; Icons
    (defun +mu4e--get-string-width (str)
      "Return the width in pixels of a string in the current
  window's default font. If the font is mono-spaced, this
  will also be the width of all other printable characters."
      (let ((window (selected-window))
            (remapping face-remapping-alist))
        (with-temp-buffer
          (make-local-variable 'face-remapping-alist)
          (setq face-remapping-alist remapping)
          (set-window-buffer window (current-buffer))
          (insert str)
          (car (window-text-pixel-size)))))

    (cl-defun +mu4e-normalised-icon (name &key set color height v-adjust)
      "Convert :icon declaration to icon"
      (let* ((icon-set (intern (concat "all-the-icons-" (or set "faicon"))))
             (v-adjust (or v-adjust 0.02))
             (height (or height 0.8))
             (icon (if color
                       (apply icon-set `(,name :face ,(intern (concat "all-the-icons-" color)) :height ,height :v-adjust ,v-adjust))
                     (apply icon-set `(,name  :height ,height :v-adjust ,v-adjust))))
             (icon-width (+mu4e--get-string-width icon))
             (space-width (+mu4e--get-string-width " "))
             (space-factor (- 2 (/ (float icon-width) space-width))))
        (concat (propertize " " 'display `(space . (:width ,space-factor))) icon)))

    (setq mu4e-use-fancy-chars t
          mu4e-headers-draft-mark      (cons "D" (+mu4e-normalised-icon "pencil"))
          mu4e-headers-flagged-mark    (cons "F" (+mu4e-normalised-icon "flag"))
          mu4e-headers-new-mark        (cons "N" (+mu4e-normalised-icon "sync" :set "material" :height 0.8 :v-adjust -0.10))
          mu4e-headers-passed-mark     (cons "P" (+mu4e-normalised-icon "arrow-right"))
          mu4e-headers-replied-mark    (cons "R" (+mu4e-normalised-icon "reply"))
          mu4e-headers-seen-mark       (cons "S" "") ;(+mu4e-normalised-icon "eye" :height 0.6 :v-adjust 0.07 :color "dsilver"))
          mu4e-headers-trashed-mark    (cons "T" (+mu4e-normalised-icon "trash"))
          mu4e-headers-attach-mark     (cons "a" (+mu4e-normalised-icon "file-text-o" :color "silver"))
          mu4e-headers-encrypted-mark  (cons "x" (+mu4e-normalised-icon "lock"))
          mu4e-headers-signed-mark     (cons "s" (+mu4e-normalised-icon "certificate" :height 0.7 :color "dpurple"))
          mu4e-headers-unread-mark     (cons "u" (+mu4e-normalised-icon "eye-slash" :v-adjust 0.05))
          mu4e-headers-list-mark       (cons "l" (+mu4e-normalised-icon "sitemap" :set "faicon"))
          mu4e-headers-personal-mark   (cons "p" (+mu4e-normalised-icon "user"))
          mu4e-headers-calendar-mark   (cons "c" (+mu4e-normalised-icon "calendar")))

    ;; Nicer threading arrows
    (setq mu4e-headers-thread-single-orphan-prefix '("─>" . "─▶")
          mu4e-headers-thread-orphan-prefix        '("┬>" . "┬▶ ")
          mu4e-headers-thread-connection-prefix    '("│ " . "│ ")
          mu4e-headers-thread-first-child-prefix   '("├>" . "├▶")
          mu4e-headers-thread-child-prefix         '("├>" . "├▶")
          mu4e-headers-thread-last-child-prefix    '("└>" . "╰▶")))
#+END_SRC

** Patch-View
#+BEGIN_SRC emacs-lisp
  (use-package message-view-patch
    :after mu4e
    :hook (gnus-part-display . message-view-patch-highlight))
#+END_SRC

** Alerts
There is also a package for mu4e which generates desktop notifications when new
emails are received. By default, I want to be notified by all messages in my
inbox and junk folder. Also, I’ll use Emacs’ default notification system, and
I’ll activate the modeline notification.

#+BEGIN_SRC emacs-lisp
  (use-package mu4e-alert
    :after mu4e
    :init
    (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
    (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
    (mu4e-alert-set-default-style 'notifications)
    :config
    (setq mu4e-alert-interesting-mail-query "flag:unread"))
#+END_SRC

* Tools
** Urls
#+BEGIN_SRC emacs-lisp
  (use-package browse-url
    :init
    (advice-add #'browse-url-xdg-open :override #'+xopen-url)
    (advice-add #'browse-url-can-use-xdg-open :override
                (defun browse-url-prefer-xopen+ ()
                  (and (or (getenv "DISPLAY")
                           (getenv "WAYLAND_DISPLAY"))
                       (executable-find "xopen"))))

    :config
    (defun +xopen-file (file &optional arg)
      (interactive "fP")
      (+xopen-url file))

    (defun +xopen-url (url &optional arg)
      "Open visited file in default external program.
  When in dired mode, open file under the cursor.
  With a prefix ARG always prompt for command to use."
      (interactive (list (or (when (derived-mode-p 'dired-mode)
                               (dired-get-file-for-visit))
                             (smart-buffer-file-name)
                             (user-error "Cannot determine file name for buffer."))
                         current-prefix-arg))

      (when (string-prefix-p "~" url)
        (setq url (expand-file-name url)))

      (let ((program (if arg
                         (read-shell-command "Open current file with: ")
                       "xopen")))
        (call-process program nil 0 nil url)))

    (defun +xopen-pdf (path page)
      (if (and (not (string-empty-p page))
               (executable-find "zathura"))
          (call-process "zathura" nil 0 nil path "--page" page)
        (+xopen-url path)))

    :general
    (:keymaps 'embark-file-map
              [remap embark-open-externally] '+xopen-file))
#+END_SRC

** Dired
#+BEGIN_SRC emacs-lisp
  (use-package dirvish
    :if (display-graphic-p)
    :init (dirvish-override-dired-mode)
    :custom
    (dirvish-cache-dir (concat +cache-dir "dirvish"))
    (dirvish-quick-access-entries
     '(("h" "~/" "Home")
       ("d" "~/Downloads/" "Downloads")
       ("c" "~/org/config" "Config")
       ("C" "~/Documents/conlanging/content" "Conlanging")))
    (dirvish-mode-line-format
     '(:left (sort file-time "" file-size symlink) :right (omit yank index)))
    (dirvish-attributes '(all-the-icons file-size collapse subtree-state vc-state git-msg))
    (dired-mouse-drag-files t)
    (mouse-drag-and-drop-region-cross-program t)
    (dired-dwim-target         t)
    (dired-recursive-copies    'always)
    (dired-recursive-deletes   'top)
    (delete-by-moving-to-trash t)
    (dired-listing-switches (string-join '("--all"
                                           "--human-readable"
                                           "--time-style=long-iso"
                                           "--group-directories-first"
                                           "-lv1")
                                         " "))
    :config
    (dirvish-peek-mode)
    :general
    (+evil
      :keymaps 'dirvish-mode-map
      :packages '(dired dirvish)
      "q" #'dirvish-quit
      "TAB" #'dirvish-subtree-toggle)
    (+local-leader-key
      :keymaps 'dirvish-mode-map
      :packages '(dired dirvish)
      "A"   #'gnus-dired-attach
      "a"   #'dirvish-quick-access
      "d"   #'dirvish-dispatch
      "e"   #'dirvish-emerge-menu
      "f"   #'dirvish-fd-jump
      "F"   #'dirvish-file-info-menu
      "h"   '(:ignore t :which-key "history")
      "hp"  #'dirvish-history-go-backward
      "hn"  #'dirvish-history-go-forward
      "hj"  #'dirvish-history-jump
      "hl"  #'dirvish-history-last
      "l"   '(:ignore t :which-key "layout")
      "ls"  #'dirvish-layout-switch
      "lt"  #'dirvish-layout-toggle
      "m"   #'dirvish-mark-menu
      "s"   #'dirvish-quicksort
      "S"   #'dirvish-setup-menu
      "y"   #'dirvish-yank-menu
      "n"   #'dirvish-narrow))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package dired-rsync
    :if (executable-find "rsync")
    :defer t
    :general
    (+evil
      :keymaps 'dired-mode-map
      :packages 'dired-rsync
      "C-r" #'dired-rsync))
#+END_SRC

** Disk Usage
Disk Usage is a file system analyzer: it offers a tabulated view of file
listings sorted by size. Directory sizes are computed recursively. The results
are cached for speed.

#+BEGIN_SRC emacs-lisp
  (use-package disk-usage)
#+END_SRC

** PDF
=pdf-tools= enables PDF support for Emacs, much better than its built-in support
with DocView. Aside from the classical settings such as keybinds, I also enable
the midnight colors by default; think of it as an equivalent of Zathura’s
recolor feature which kind of enables a dark mode for PDFs.

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :hook (pdf-tools-enabled . pdf-view-midnight-minor-mode)
    :general
    (+leader-key
      :keymaps 'pdf-view-mode-map
      :packages 'pdf-tools
      "y"   #'pdf-view-kill-ring-save
      "t"   #'evil-collection-pdf-view-next-line-or-next-page
      "s"   #'evil-collection-pdf-view-previous-line-or-previous-page)
    (+local-leader-key
      :keymaps 'pdf-view-mode-map
      :packages 'pdf-tools
      "a"  '(:ignore t :which-key "annotations")
      "aD" #'pdf-annot-delete
      "at" #'pdf-annot-attachment-dired
      "ah" #'pdf-annot-add-highlight-markup-annotation
      "al" #'pdf-annot-list-annotations
      "am" #'pdf-annot-markup-annotation
      "ao" #'pdf-annot-add-strikeout-markup-annotation
      "as" #'pdf-annot-add-squiggly-markup-annotation
      "at" #'pdf-annot-add-text-annotation
      "au" #'pdf-annot-add-underline-markup-annotation

      "f"  '(:ignore t :which-key "fit")
      "fw" #'pdf-view-fit-width-to-window
      "fh" #'pdf-view-fit-height-to-window
      "fp" #'pdf-view-fit-page-to-window

      "s"  '(:ignore t :which-key "slice/search")
      "sb" #'pdf-view-set-slice-from-bounding-box
      "sm" #'pdf-view-set-slice-using-mouse
      "sr" #'pdf-view-reset-slice
      "ss" #'pdf-occur

      "o"  'pdf-outline
      "m"  'pdf-view-midnight-minor-mode)
    :config
    (+register-build-function #'pdf-tools-install))
#+END_SRC

One thing =pdf-tools= doesn’t handle is restoring the PDF to the last point it was visited — in other words, open the PDF where I last left it.

#+BEGIN_SRC emacs-lisp
  (use-package pdf-view-restore
    :after pdf-tools
    :hook (pdf-view-mode . pdf-view-restore-mode)
    :config
    (setq pdf-view-restore-filename (expand-file-name ".tmp/pdf-view-restore"
                                                      +state-dir)))
#+END_SRC

** Logview
#+BEGIN_SRC emacs-lisp
  (use-package logview
    :hook (
           (logview-mode . read-only-mode)
           (logview-mode . auto-revert-tail-mode))
    :custom
    (logview-views-file (expand-file-name "logview.views" +data-dir))
    (logview-cache-filename (expand-file-name "logview-cache.extmap" +cache-dir)))
#+END_SRC

** Ripgrep
#+BEGIN_SRC emacs-lisp
  (use-package ripgrep
    :if (executable-find "rg")
    :config
    (use-package rg
      :hook (after-init . rg-enable-default-bindings))
    ;; grep settings
    (require 'grep)
    (grep-apply-setting
     'grep-command "rg --color=auto --null -nH --no-heading -e ")
    (grep-apply-setting
     'grep-template "rg --color=auto --null --no-heading -g '!*/' -e <R> <D>")
    (grep-apply-setting
     'grep-find-command '("rg --color=auto --null -nH --no-heading -e ''" . 38))
    (grep-apply-setting
     'grep-find-template "rg --color=auto --null -nH --no-heading -e <R> <D>"))
#+END_SRC

** XRef
Cross-referencing.

#+BEGIN_SRC emacs-lisp
  (use-package xref
    :straight (:type built-in)
    :hook ((xref-after-return xreft-after-jumper) . recenter)
    :custom
    (setq xref-search-program 'ripgrep)
    (xref-history-storage 'xref-window-local-history)
    (xref-show-xrefs-function #'xref-show-definitions-completing-read)
    (xref-show-definitions-function #'xref-show-definitions-completing-read))
#+END_SRC

** Compile
#+BEGIN_SRC emacs-lisp
  (use-package compile
    :defer t
    :straight (:type built-in)
    :hook (
           (compilation-filter . colorize-compilation-buffer)
           (next-error . recenter))
    :init
    (require 'ansi-color)
    (defun colorize-compilation-buffer ()
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max))))
    :custom
    (compilation-scroll-output 'first-error)
    (compilation-always-kill t)
    (compilation-ask-about-save nil)
    (compilation-skip-threshold 0)
    (compilation-read-command nil)
    (compilation-message-face 'default)
    (next-error-verbose nil)
    (next-error-message-highlight nil)
    :config
    (defun +prettify-compilation (&rest _)
      "Prettify compilation buffer."
      (with-current-buffer "*compilation*"
        (toggle-truncate-lines -1)
        (highlight-regexp "FAIL.*" 'diff-error)))
    (advice-add 'compile :after #'+prettify-compilation)
    ;; Evil
    (evil-set-command-property 'next-error :jump t)
    (evil-set-command-property 'previous-error :jump t)
    (evil-set-initial-state 'compilation-mode 'normal))
#+END_SRC

This package provides a command that can be used to run compilation commands
that match one or more predicates for the current directory or project. This can
be used for example to list all of the makefile targets of a project and then
execute one.
#+BEGIN_SRC emacs-lisp
  (use-package compile-multi
    :straight (compile-multi :type git :host github
                             :repo "mohkale/compile-multi")
    :custom
    (compile-multi-default-directory #'+project-root)
    :config
    ;;; C++
    ;; O2
    (setq compile-multi-config nil)
    (push '((string-match-p (regexp-quote "O2") (project-root (project-current t)))
            ("aliBuild:build" (format "cd %s && aliBuild build O2 --debug" (file-name-directory (getenv "ALIBUILD_WORK_DIR")))
             ))
          compile-multi-config)

    (setenv "ALIBUILD_WORK_DIR" "/home/f3sch/git/alice/sw")

    ;; ELisp
    (defun +byte-compile-this-file ()
      (byte-compile-file (buffer-file-name)))

    (push '(emacs-lisp-mode
            ("emacs:bytecompile" . ,#'+byte-compile-this-file))
          compile-multi-config)

    ;; Makefile
    (push '((file-exists-p "Makefile")
            ("make:build" . "make build")
            ("make:test" . "make test")
            ("make:all" . "make all"))
          compile-multi-config))
#+END_SRC

** Info
#+BEGIN_SRC emacs-lisp
  (use-package info
    :straight (:type built-in)
    :general
    (+evil
      :keymaps 'Info-mode-map
      "c" #'Info-prev
      "t" #'evil-scroll-down
      "s" #'evil-scroll-up
      "r" #'Info-next
      "?" #'Info-toc
      "b" #'Info-history-back
      "f" #'Info-history-forward
      "m" #'Info-menu
      "t" #'Info-top-node
      "u" #'Info-up))
#+END_SRC

** Tramp
#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :straight (:type built-in)
    :custom
    (tramp-default-method "ssh")
    (tramp-default-remote-shell "/bin/bash")
    (tramp-shell-prompt-pattern "\\(?:^\\|\n\\|\x0d\\)[^]#$%>\n]*#?[]#$%>] *\\(\e\\[[0-9;]*[a-zA-Z] *\\)*")
    :config
    ;; This is needed for tramp to respect remote PATH variable
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
    (add-to-list 'tramp-backup-directory-alist  (cons tramp-file-name-regexp nil)))
#+END_SRC

** Spelling
*** Dictionary
#+BEGIN_SRC emacs-lisp
  (use-package dictionary
    :straight (:type built-in)
    :bind
    ("M-#" . dictionary-lookup-definition))
#+END_SRC

*** Flyspell
#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :straight (:type built-in)
    :hook
    ((text-mode . flyspell-mode)
     (prog-mode . flyspell-prog-mode))
    :init
    (defun +flyspell-on-for-buffer-type ()
      "Enable Flyspell appropriately for the major mode of the current
  buffer. Uses `flyspell-prog-mode' for modes derived from
  `prog-mode', so only strings and comments get checked. All other
  buffers get `flyspell-mode' to check all text. If flyspell is
  already enabled, does nothing."
      (interactive)
      (if (not (symbol-value flyspell-mode))
          (if (derived-mode-p 'prog-mode)
              (flyspell-prog-mode)
            (flyspell-mode +1))))
    (defun +flyspell-toggle ()
      "Turn Flyspell on if it is off, or off if it is on.  When turning
  on, it uses `flyspell-on-for-buffer-type' so code-vs-text is
  handled appropriately."
      (interactive)
      (if (symbol-value flyspell-mode)
          (progn
            (message "Flyspell off")
            (flyspell-mode -1))
        (+flyspell-on-for-buffer-type)))
    :custom
    (flyspell-issue-welcome-flag nil)
    (flyspell-issue-message-flag nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :straight (:type built-in)
    :after flyspell
    :custom
    (ispell-program-name "aspell")
    (ispell-list-command "--list")
    (ispell-extra-args '("--sug-mode=ultra"
                         "--run-together"
                         "--encoding=utf-8"))
    :config
    (add-hook 'text-mode-hook
              (defun +ispell-remove-run-together-for-aspell-h ()
                (setq-local ispell-extra-args (remove "--run-together" ispell-extra-args)))))
#+END_SRC

Correct misspelled words using vertico
#+BEGIN_SRC emacs-lisp
  (use-package flyspell-correct
    :after flyspell
    :general ([remap ispell-word] #'flyspell-correction-at-point))
#+END_SRC

*** Flymake
#+BEGIN_SRC emacs-lisp
  (use-package flymake
    :straight (:type built-in)
    :custom
    (flymake-note-bitmap '(+dot-fringe-bitmap compilation-info))
    (flymake-error-bitmap '(+dot-fringe-bitmap compilation-error))
    (flymake-warning-bitmap '(+dot-fringe-bitmap compilation-warning))

    :init
    (evil-declare-motion 'flymake-goto-next-error)
    (evil-declare-motion 'flymake-goto-prev-error)
    (evil-declare-motion 'flymake-first-error+)
    (evil-declare-motion 'flymake-last-error+)

    ;; Disable the legacy proc backend.
    (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake)

    :config
    (evil-set-command-property 'flymake-goto-next-error :jump t)
    (evil-set-command-property 'flymake-goto-prev-error :jump t)

    ;; Make the diagnostic buffer auto-move to the closest error.
    (advice-add #'flymake-show-buffer-diagnostics :filter-return
                (defun flymake-show-buffer-diagnostics-update-point+ (result)
                  "Move point to the error closest to point in diagnostics buffer.
  By default when you run `flymake-show-buffer-diagnostics' your point is
  either the start of the buffer or where it was when you were previously
  in that buffer.
  This isn't ideal when you just want to inspect the error message for the
  error at point. This advice moves the point to the closest error in the
  diagnostics buffer to where you were in the original buffer."
                  (with-current-buffer (flymake--diagnostics-buffer-name)
                    (when-let* ((source flymake--diagnostics-buffer-source)
                                (diag-deltas
                                 (with-current-buffer source
                                   (let ((point (point)))
                                     (cl-loop for it in (cl-sort (flymake-diagnostics) #'<
                                                                 :key #'flymake-diagnostic-beg)
                                              collect (abs (- (flymake-diagnostic-beg it) point)))))))
                      (goto-char (point-min))
                      (let ((ix (seq-position diag-deltas (seq-min diag-deltas))))
                        (forward-line ix))))
                  result))

    (flymake-mode)
    :general
    (:keymaps 'flymake-diagnostics-buffer-mode-map
              :states 'motion
              "RET" 'flymake-goto-diagnostic
              "o" 'flymake-show-diagnostic))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package flymake-diagnostic-at-point
    :after flymake
    :custom
    (flymake-diagnostic-at-point-display-diagnostic-function 'flymake-diagnostic-at-point-display-popup)
    :hook (flymake-mode-hook . flymake-diagnostic-at-point-mode))

  (use-package flymake-collection
  :hook (after-init . flymake-collection-hook-setup))
#+END_SRC

** Keycast
In case I am sharing my screen with people and I want to show which functions
are called on my keystrokes since I don’t exactly use standard keybindings.

#+begin_src emacs-lisp
(use-package keycast
  :defer t
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (add-hook 'pre-command-hook 'keycast--update t)
      (remove-hook 'pre-command-hook 'keycast--update)))
  (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
#+end_src

** Keyfreq
Keyfreq is a package that records all the commands I call from Emacs and builds
a heatmap out of it.

#+begin_src emacs-lisp
(use-package keyfreq
  :init
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)
  :config
  (setq keyfreq-excluded-commands '(self-insert-command org-self-insert-command
                                    evil-previous-visual-line evil-next-visual-line
                                    ivy-next-line evil-backward-char evil-forward-char
                                    evil-next-line evil-previous-line evil-normal-state
                                    text-scale-pinch)))
#+end_src

** Info Colours
#+BEGIN_SRC emacs-lisp
  (use-package info-colors
    :commands (info-colors-fontify-node)
    :config
    (add-hook 'Info-selection-hook 'info-colors-fontify-node))
#+END_SRC

* Security
** EPG
#+BEGIN_SRC emacs-lisp
  (use-package epg
    :straight (:type built-in)
    :custom
    (epg-pinentry-mode 'loopback)
    (epg-user-id "BE70541948D9FB3FF0674B92997C87E6BE5239F0"))
#+END_SRC

** EPA
#+BEGIN_SRC emacs-lisp
  (use-package epa
    :straight (:type built-in)
    ;; force Emacs to use its own internal password prompt instead of an external
    ;; pinentry program.
    :preface (setenv "GPG_AGENT_INFO" nil)
    :custom
    (epa-pinentry-mode 'loopback) ; let EasyPG Assistant to use loopback for pinentry.
    (epa-file-inhibit-auto-save t)
    (epa-keyserver "keys.openpgp.org")
    (epa-file-select-keys (if (null epa-file-encrypt-to) t nil))
    :commands (epa-search-keys)
    :init
    (add-to-list 'display-buffer-alist '("^\\*Keys\\*" . (display-buffer-below-selected))))
#+END_SRC

** MM-Encode
#+BEGIN_SRC emacs-lisp
  (use-package mm-encode
    :straight (:type built-in)
    :custom
    (mm-encrypt-option nil)
    (mm-sign-option nil)
    (mm-verify-option 'known)
    (gnus-buttonized-mime-types '("multipart/signed")))
#+END_SRC

** MML-Sec
#+BEGIN_SRC emacs-lisp
  (use-package mml-sec
    :straight (:type built-in)
    :custom
    (mml2015-use 'epg)
    (mml-secure-smime-encrypt-to-self  t)
    (mml-secure-smime-sign-with-sender t)
    (mml-secure-openpgp-encrypt-to-self  t)
    (mml-secure-openpgp-sign-with-sender t)
    (mml-secure-openpgp-signers '("BE70541948D9FB3FF0674B92997C87E6BE5239F0")))
#+END_SRC

* Fun
** Screenshots
Use the built-in support via cairo.
#+BEGIN_SRC emacs-lisp
  (defun self-screenshot (&optional type)
    "Save a screenshot of type TYPE of the current Emacs frame.
  As shown by the function `', type can weild the value `svg',
  `png', `pdf'.

  This function will output in /tmp a file beginning with \"Emacs\"
  and ending with the extension of the requested TYPE."
    (interactive (list
                  (intern (completing-read "Screenshot type: "
                                           '(png svg pdf postscript)))))
    (let* ((extension (pcase type
                        ('png        ".png")
                        ('svg        ".svg")
                        ('pdf        ".pdf")
                        ('postscript ".ps")
                        (otherwise (error "Cannot export screenshot of type %s" otherwise))))
           (filename (make-temp-file "Emacs-" nil extension))
           (data     (x-export-frames nil type)))
      (with-temp-file filename
        (insert data))
      (kill-new filename)
      (message filename)))
#+END_SRC

=screenshot.el= is a nice utility package made by TEC. It allows the user to
take a screenshot of a specific area of a buffer and make it look nice.

#+BEGIN_SRC emacs-lisp
  (use-package screenshot
    :commands screenshot
    :straight (screenshot :build t
                          :type git
                          :host github
                          :repo "tecosaur/screenshot"))
#+END_SRC

** Emojify
#+BEGIN_SRC emacs-lisp
  (use-package emojify
    :hook (after-init . global-emojify-mode))
#+END_SRC

* Keybindings
** Functions
#+BEGIN_SRC emacs-lisp
  (defun +open-config ()
    "Open the config file."
    (interactive)
    (find-file +config-file))
#+END_SRC

** Emacs Bindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-s") 'consult-line)
#+END_SRC

** Leader Bindings
*** Buffers
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "b"
    "" '(:ignore t :wk "Buffers")
    "b" '(persp-switch-to-buffer* :wk "Switch")
    "B" '(ibuffer :wk "All Buffers")
    "k" '(persp-kill-buffer* :wk "Kill"))
#+END_SRC

*** Code
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "c"
    "" '(:ignore t :wk "Code")
    "d" '(eglot-find-declaration :wk "Find Declaration")
    "a" '(xref-find-apropos :wk "Find All Matches")
    "f" '(eglot-format :wk "Format Region")
    "s" '(consult-eglot-symbols :wk "Show Symbols")
    "g" '(xref-find-definitions :wk "Find Definition")
    "F" '(apheleia-format-buffer :wk "Format Buffer")
    "t" '(eglot-find-typeDefinition :wk "Find Type Definition")
    "i" '(eglot-find-implementation :wk "Find Implementation")
    "r" '(xref-find-references :wk "Find References")
    "R" '(eglot-rename :wk "Rename")

    "e" '(:ignore t :wk "Eglot")
    "er" '(eglot-reconnect :wk "Reconnect")
    "es" '(eglot-shutdown :wk "Shutdown")
    "eS" '(eglot-shutdown-all :wk "Shutdown All")
    "ec" '(eglot-show-workspace-configuration :wk "Show Configuration")

    "A" '(:ignore t :wk "Select Code Action")
    "Aq" '(eglot-code-action-quickfix :wk "Quickfix")
    "Ar" '(eglot-code-action-rewrite :wk "Rewrite")
    "Ai" '(eglot-code-action-inline :wk "Inline")
    "Ae" '(eglot-code-action-extract :wk "Extract")
    "Ao" '(eglot-code-action-organize-imports :wk "Organize Imports")
    "a" '(eglot-code-actions :wk "Code Actions"))
#+END_SRC

*** Files
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "f"
    "" '(:ignore t :wk "Files")
    "s" '(save-buffer :wk "Save Buffer")
    "f" '(find-file :wk "Find File")
    "r" '(rename-visited-file :wk "Rename Visited File")
    "R" '(rename-file :wk "Rename File"))
#+END_SRC

*** Git
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "g"
    "" '(:ignore t :wk "Git")
    "D" '(vc-diff :wk "Show Diff")
    "d" '(vc-ediff :wk "Show Diff")
    "s" '(git-gutter:stage-hunk :wk "Stage Hunk")
    "r" '(git-gutter:revert-hunk :wk "Revert Hunk")
    "R" '(vc-revert :wk "Revert File")
    "n" '(git-gutter:next-hunk :wk "Next Hunk")
    "p" '(git-gutter:previous-hunk :wk "Previous Hunk")
    "g" '(magit-status :wk "Status"))
#+END_SRC

*** Help
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "h"
    "" '(:ignore t :wk "Help")
    "h" '(helpful-at-point :wk "At Point")
    "c" '(helpful-callable :wk "Callable")
    "C" '(helpful-command :wk "Command")
    "s" '(helpful-symbol :wk "Symbol")
    "f" '(helpful-function :wk "Function")
    "v" '(helpful-variable :wk "Variable")
    "V" '(helpful-visit-reference :wk "Visit")
    "m" '(helpful-macro :wk "Macro")
    "k" '(helpful-key :wk "Key"))
#+END_SRC

*** Project
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "p"
    "" '(:ignore t :wk "Project")
    "p" '(project-switch-project :wk "Switch Project")
    "b" '(consult-project-buffer :wk "Switch Buffer")
    "f" '(project-find-file :wk "Find File")
    "k" '(project-kill-buffers :wk "Kill Project Buffers")
    "r" '(project-find-regexp :wk "Search by regexp")
    "g" '(consult-git-grep :wk "Git Grep")
    "o" '(consult-project-extra-find :wk "Find Endpoint")
    "O" '(consult-project-extra-find-other-window :wk "Find Endpoint other Window")
    "c" '(compile-multi :wk "Compile Project")
    "v" '(project-vc-dir :wk "Open vc Dialog")
    "s" '(project-shell :wk "Open Shell")
    "d" '(project-dired :wk "Open Dired"))
#+END_SRC

*** Open
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "o"
    "" '(:ignore t :wk "Open")
    "m" '(mu4e :wk "Mail")
    "T" '(consult-theme :wk "Pick Theme")
    "f" '(+open-config :wk "Edit Config")
    "-" '(dirvish :wk "Dired")
    "s" '(dirvish-side :wk "Sidebar"))
#+END_SRC

*** Toggle
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "t"
    "" '(:ignore t :wk "Toggle")
    "d" '(disk-usage-here :wk "Show Disk Usage Here"))
#+END_SRC

*** Window
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "w"
    "" '(:ignore t :wk "Window Managment")

    ;; Movement
    "l" '(windmove-right :wk "Move Right")
    "j" '(windmove-down :wk "Move Down")
    "k" '(windmove-up :wk "Move Up")
    "h" '(windmove-left :wk "Move Left")

    ;; Swap
    "TAB" '(:ignore t :wk "Swap Windows")
    "TAB h" '(windmove-swap-states-left :wk "Swap Left")
    "TAB j" '(windmove-swap-states-down :wk "Swap Down")
    "TAB k" '(windmove-swap-states-up :wk "Swap Up")
    "TAB l" '(windmove-swap-states-right :wk "Swap Right")

    ;; Re-/Undo
    "u" '(winner-undo :wk "Undo Window Change")
    "r" '(winner-redo :wk "Redo Window Change")

    ;; Split
    "s" '(evil-window-split :wk "Split")
    "S" '(+evil-window-split-follow :wk "Split and Follow")
    "v" '(evil-window-vsplit :wk "VSplit")
    "V" '(+evil-window-vsplit-follow :wk "VSplit and Follow")

    ;; Delete
    "d" '(delete-window :wk "Delete")
    "D" '(:ignore t :wk "Delete Windows")
    "Dh" '(windmove-delete-right :wk "Delete Right")
    "Dj" '(windmove-delete-down :wk "Delete Down")
    "Dk" '(windmove-delete-up :wk "Delete Up")
    "Dl" '(windmove-delete-left :wk "Delete Left")
    "Do" '(delete-other-windows :wk "Delete All Other Windows")

    ;; Rotating
    "c" '(rotate-window :wk "Cycle Window")
    "C" '(rotate-layout :wk "Cycle Layout")

    ;; Quitting
    "q" '(evil-window-delete :wk "Delete Window")
    "Q" '(save-buffers-kill-emacs :wk "Save all Buffers and Kill Emacs"))
#+END_SRC

*** Workspaces
#+BEGIN_SRC emacs-lisp
  (+leader-key
    :infix "TAB"
    "" '(:ignore t :wk "Workspaces")
    "b" '(persp-switch-to-buffer :wk "Switch to Buffer")
    "F" '(make-frame :wk "New Frame")
    "n" '(persp-switch :wk "New")
    "m" '(persp-merge :wk "Merge")
    "u" '(persp-unmerge :wk "Unmerge")
    "s" '(persp-state-save :wk "Save State")
    "l" '(persp-state-load :wk "Load State")
    "i" '(persp-import :wk "Import a Perspective into another Frame")
    "TAB" '(persp-switch :wk "Switch")
    "`" '(persp-switch-by-number :wk "Switch by Number")
    "-" '(persp-remove-buffer :wk "Remove Buffer")
    "+" '(persp-set-buffer :wk "Add Buffer")
    "r" '(persp-rename :wk "Rename Perspective")
    "d" '(persp-kill :wk "Delete")
    "]" '(persp-next :wk "Next")
    "[" '(persp-prev :wk "Previous")
    "D" '(:ignore t :wk "Desktop")
    "Ds" '(desktop-save :wk "Save Current Session")
    "Dr" '(desktop-read "Load Last Session"))
#+END_SRC

*** Special
#+BEGIN_SRC emacs-lisp
  (+leader-key
    "/" '(consult-ripgrep :wk "Ripgrep")
    "." '(consult-line :wk "Search File")
    "X" '(persp-switch-to-scratch-buffer :wk "Scratch Buffer")
    "x" '(org-capture :wk "Capture")
    "SPC" '(consult-find :wk "Find File")

    "-" '(:ignore t :wk "Emacs Profiler")
    "-s" '(profiler-start :wk "Profiler Start")
    "-b" '(profiler-stop :wk "Profiler Stop")
    "-r" '(profiler-report :wk "Profiler Report")

    "`" '(:ignore t :wk "Screenshot")
    "`s" '(screenshot :wk "Screnshot Buffer")
    "`S" '(self-screenshot :wk "Screnshot Emacs"))
#+END_SRC

* EOF
Here, I add the ability to tangle this file automatically when changed and
subsequently saved.

** Tangle Config File
A simple function that tangles this file.

#+BEGIN_SRC emacs-lisp
  (defun +tangle-config ()
    "Tangle the `+config-file'."
    (message "Start tangling.")
    (require 'org)
    (org-babel-tangle-file +config-file (file-name-concat user-emacs-directory "init.el") "emacs-lisp")
    (message "Successfully tangled config file."))
#+END_SRC

** Add-hook
Emacs considers some file local variables unsafe, e.g., =after-save-hook=.
Hence, I add it as a safe pair, with =+tangle-config= function, to the
=safe-local-variable-values= variable.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'safe-local-variable-values '(after-save-hook . +tangle-config))
#+END_SRC

Installs a file local hook, to tangle this file.
# Local Variables:
# after-save-hook: +tangle-config
# eval: (display-line-numbers-mode)
# End:

** EOF
#+BEGIN_SRC emacs-lisp
  ;; Local Variables:
  ;; no-byte-compile: t
  ;; no-native-compile: t
  ;; no-update-autoloads: t
  ;; End:
#+END_SRC
