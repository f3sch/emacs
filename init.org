#+TITLE: My Emacs Configuration
#+AUTHOR: Felix Schlepper

* Early-Init
This file is loaded before the package system and GUI is initialized.
A detailed description is [[elisp:(info "(emacs) Early Init File")][here]].

** Small Startup Optimizations
This avoids garabage collection during startup.
Afterward, sensible defaults are renabled.

#+begin_src emacs-lisp :tangle early-init.el
  (defvar file-name-handler-alist-old file-name-handler-alist)
  (setq file-name-handler-alist nil
	message-log-max 16384
	gc-cons-threshold most-positive-fixnum
	gc-cons-percentage 0.6)
  (add-hook 'after-init-hook (lambda ()
			       (setq file-name-handler-alist file-name-handler-alist-old
				     gc-cons-threshold (* 16 1024 1024)
				     gc-cons-percentage 0.1)
			       (garbage-collect))
	    t)
#+end_src

** Native Compilation
Asynchronous compilation and speed, enabled.

#+begin_src emacs-lisp :tangle early-init.el
  (let ((path (expand-file-name "eln-cache/" user-emacs-directory)))
    (setq native-comp-eln-load-path (list path)
	  native-compile-target-directory path))
  (setq native-comp-async-report-warnings-errors nil ;; Silence compiler warnings as they can be pretty disruptive
	native-compile-prune-cache t
	native-comp-speed 2
	native-comp-deferred-compilation	 nil)  ;; Make native compilation happens asynchronously

  (setq load-prefer-newer noninteractive)
#+end_src

** Unstyled Emacs
Maximize Frame and do not show unstyled Emacs.

#+begin_src emacs-lisp :tangle early-init.el
  (setq-default frame-inhibit-implied-resize t)
  ;; HACK: Don't show size info (or anything else) in frame title
  (setq-default frame-title-format "\n")
  ;; Disable start-up screen
  (setq-default inhibit-startup-screen t)
  (setq-default inhibit-startup-message t)

  ;; UnsetSRF
  (setq site-run-file nil)
  ;; -UnsetSRF

  ;; Maximize the Emacs frame on startup
  (push '(fullscreen . maximized) initial-frame-alist)
  (push '(fullscreen . maximized) default-frame-alist)

  ;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
  ;; Disable tool and scrollbars. These are just clutter (the scrollbar also
  ;; impacts performance).
  (push '(tool-bar-lines . 0)	default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)
  (customize-set-variable 'tool-bar-mode nil)
  (customize-set-variable 'scroll-bar-mode nil)
#+end_src

** Scratch Buffer
Set the scratch buffer initial mode.
This pulls in a whole lot of packages, but I do not care about the startup time.

#+begin_src emacs-lisp :tangle early-init.el
  ;; Fundamental mode at startup.
  (setq initial-major-mode 'emacs-lisp-mode)
#+end_src

** Package.el
Required by straight.el.

#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil)
#+end_src

* Startup
** Load Time
Although I do not care about startup time, I want to see it.

#+begin_src emacs-lisp
    (defconst emacs-start-time (current-time))
    (defun report-time-since-load (&optional suffix)
      (message "Loading init...done (%.3fs)%s"
	       (float-time (time-subtract (current-time) emacs-start-time))
	       suffix))

    (add-hook 'after-init-hook
	      #'(lambda () (report-time-since-load " [after-init]"))
	      t)
#+end_src

** Bootstrap straight.el
For now I use straight.el as a package manager.

#+begin_src emacs-lisp
    (defvar bootstrap-version)
    (let ((bootstrap-file
	   (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	  (bootstrap-version 6))
      (unless (file-exists-p bootstrap-file)
	(with-current-buffer
	    (url-retrieve-synchronously
	     "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
	     'silent 'inhibit-cookies)
	  (goto-char (point-max))
	  (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))
    (setq straight-use-package-by-default t)

      ;;; Paths
    (setq package-user-dir (expand-file-name "packages" user-emacs-directory)
	  url-history-file (expand-file-name "url/history" user-emacs-directory)
	  custom-file (expand-file-name "custom.el" user-emacs-directory))


    (use-package diminish)
#+end_src

* General
** Library Functions
Mostly taken from doomemacs.
#+BEGIN_SRC emacs-lisp
(defmacro appendq! (sym &rest lists)
  "Append LISTS to SYM in place."
  `(setq ,sym (append ,sym ,@lists)))

(defmacro setq! (&rest settings)
  "A more sensible `setopt' for setting customizable variables.

This can be used as a drop-in replacement for `setq' and *should* be used
instead of `setopt'. Unlike `setq', this triggers custom setters on variables.
Unlike `setopt', this won't needlessly pull in dependencies."
  (macroexp-progn
   (cl-loop for (var val) on settings by 'cddr
            collect `(funcall (or (get ',var 'custom-set) #'set-default-toplevel-value)
                              ',var ,val))))

(defmacro delq! (elt list &optional fetcher)
  "`delq' ELT from LIST in-place.

If FETCHER is a function, ELT is used as the key in LIST (an alist)."
  `(setq ,list (delq ,(if fetcher
                          `(funcall ,fetcher ,elt ,list)
                        elt)
                     ,list)))

(defmacro pushnew! (place &rest values)
  "Push VALUES sequentially into PLACE, if they aren't already present.
This is a variadic `cl-pushnew'."
  (let ((var (make-symbol "result")))
    `(dolist (,var (list ,@values) (with-no-warnings ,place))
       (cl-pushnew ,var ,place :test #'equal))))

(defmacro prependq! (sym &rest lists)
  "Prepend LISTS to SYM in place."
  `(setq ,sym (append ,@lists ,sym)))
#+END_SRC

** Config File
A useful variable to have.

#+BEGIN_SRC emacs-lisp
  (defvar +config-file (file-name-concat user-emacs-directory "init.org")
    "User config file.")
#+END_SRC

** No-littering
Stop emacs from littering with sensible defaults to paths.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :demand t
    :diminish
    :config
    ;; save auto-save file if needed
    (setq auto-save-file-name-transforms
	  `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

    ;; exclude these in recentf
    (with-eval-after-load 'recentf
      (appendq! recentf-exclude
		`(,no-littering-var-directory ,no-littering-etc-directory))))
#+END_SRC

** Backups
I don’t use backup files often as I use git to manage most of my files.
However, I still feel safer when having a backup.  Save backup files to a
dedicated directory.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.cache/emacs/backups")))
(with-eval-after-load 'tramp
  (add-to-list 'tramp-backup-directory-alist
	       (cons tramp-file-name-regexp nil)))
(setq delete-old-versions t)
;; Backup also files under VC.
(setq version-control t
      vc-make-backup-files t)
;; Make numeric backup versions unconditionally.
;; auto-save-mode doesn't create the path automatically!
(make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)
(setq auto-save-list-file-prefix
      (expand-file-name "tmp/auto-saves/sessions/" user-emacs-directory))
(setq auto-save-file-name-transforms
      `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t)))
#+END_SRC

** Recent Files
Emacs cleans sometimes up.
I do not need to know when it does...

#+BEGIN_SRC emacs-lisp
  (defun +no-msg (function)
    "Prevent FUNCTION from showing `Wrote <FILE>' messages. (The
  messages are still logged to `*Messages*'.)"
    (let ((inhibit-message  t))	   (funcall function)))
  (advice-add 'recentf-save-list :around '+no-msg)
  (add-hook 'after-init-hook #'recentf-mode)
  (with-eval-after-load 'recentf
    (setq recentf-max-saved-items 300
	  recentf-exclude
	  '("\\.?cache" ".cask" "url" "COMMIT_EDITMSG\\'" "bookmarks"
	    "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\|bmp\\|xpm\\)$"
	    "\\.?ido\\.last$" "\\.revive$" "/G?TAGS$" "/.elfeed/"
	    "^/tmp/" "^/var/folders/.+$" "^/ssh:" "/persp-confs/"
	    (lambda (file) (file-in-directory-p file package-user-dir))))
    (push (expand-file-name recentf-save-file) recentf-exclude)
    (add-to-list 'recentf-filename-handlers #'abbreviate-file-name))
#+END_SRC

** Text Encoding
UTF-8; universally used, but not understood.

#+BEGIN_SRC emacs-lisp
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (set-charset-priority 'unicode)
#+END_SRC

** Blinking Cursor
A cursor is an artifact of video and should blink. Not convinced?
Then read https://www.inverse.com/innovation/blinking-cursor-history

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 1)
#+END_SRC

** Garbage Collection
Let smarter people than me think about GC.

#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :diminish
    :hook (after-init . gcmh-mode)
    :custom
    (gcmh-idle-delay 'auto)
    ;; Garbage-collect on focus-out
    (add-function :after after-focus-change-function
		  (defun +garbage-collect-maybe ()
		    (unless (frame-focus-state)
		      (garbage-collect)))))
#+END_SRC

** Save Place
Saves the last position of pointer in a file.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook #'save-place-mode)
  (setq save-place-forget-unreadable-files nil)
#+END_SRC

** Clipboard
For better clipboard integration in Linux.

#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard t
	select-enable-primary t
	save-interprogram-paste-before-kill t)
#+END_SRC

** CJK Encoding
Me no able speak CJK (Chinese/Japanese/Korean characters).

#+BEGIN_SRC emacs-lisp
  (setq utf-translate-cjk-mode nil)
#+END_SRC

** Line Numbering
I need relative line numbers, so evil can take me where I want to go.

#+BEGIN_SRC emacs-lisp
  (setq display-line-numbers-type 'relative)
#+END_SRC

Activate in all modes deriving from =prog-mode=.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+END_SRC

Explicitly define a width to reduce the cost of on-the-fly computation

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers-width 3)
#+END_SRC

Show absolute line numbers for narrowed regions to make it easier to tell the
buffer is narrowed, and where you are, exactly.

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers-widen t)
#+END_SRC

** Scrolling
Keep text somewhat centered.

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 5
	scroll-step 1)
#+END_SRC

Emacs spends too much effort re-centering the screen if you scroll the cursor
more than N lines past window edges (where N is the settings of
`scroll-conservatively').  This is especially slow in larger files during
large-scale scrolling commands. If kept high enough, the window is never
automatically re-centered.

#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 10000)
#+END_SRC

Pixel wise precision when scrolling.
#+BEGIN_SRC emacs-lisp
  (pixel-scroll-precision-mode)
#+END_SRC

** Frames
Don't resize the frames in steps; it looks weird, especially in tiling window
managers, where it can leave unseemly gaps.

#+BEGIN_SRC emacs-lisp
  (setq frame-resize-pixelwise t)
#+END_SRC

But do not resize windows pixelwise, this can cause crashes in some cases when
resizing too many windows at once or rapidly.

#+BEGIN_SRC emacs-lisp
  (setq window-resize-pixelwise nil)
#+END_SRC

GUIs are inconsistent across systems, desktop environments, and themes, and
don't match the look of Emacs. They also impose inconsistent shortcut key
paradigms. I'd rather Emacs be responsible for prompting.

#+BEGIN_SRC emacs-lisp
  (setq use-dialog-box nil)
#+END_SRC

Favor vertical splits over horizontal ones. Monitors are trending toward wide,
rather than tall.

#+BEGIN_SRC emacs-lisp
  (setq split-width-threshold 160
	split-height-threshold nil)
#+END_SRC

** Minibuffer
Allow for minibuffer-ception. Sometimes we need another minibuffer command while
we're in the minibuffer.

#+BEGIN_SRC emacs-lisp
  (setq enable-recursive-minibuffers t)
#+END_SRC

Show current key-sequence in minibuffer ala 'set showcmd' in vim. Any feedback
after typing is better UX than no feedback at all.

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.02)
#+END_SRC

Expand the minibuffer to fit multi-line text displayed in the echo-area. This
doesn't look too great with direnv, however...

#+BEGIN_SRC emacs-lisp
  (setq resize-mini-windows 'grow-only)
#+END_SRC


Typing yes/no is obnoxious when y/n will do

#+BEGIN_SRC emacs-lisp
  (setq use-short-answers t)
#+END_SRC

Try to keep the cursor out of the read-only portions of the minibuffer.

#+BEGIN_SRC emacs-lisp
  (setq minibuffer-prompt-properties '(read-only t intangible t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+END_SRC

** Lockfiles
Disable Lockfiles.

#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

** Echo
This is a built-in feature I didn't expect to be useful.  If you type part of
keybinding, Emacs will display this part in the echo area after a timeout.  One
second is a bit too long though for my taste.

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.2)
#+END_SRC

** Display raw bytes as hex
Title says it all.  \x rules \xDEADBEEF

#+BEGIN_SRC emacs-lisp
  (setq display-raw-bytes-as-hex t)
#+END_SRC

** Unconditionally Kill Sub-Processes
Sometimes there processes which do not want to die and then there is vterm.

#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-processes nil)
#+END_SRC

And finally, the prompt that asks you if you want to kill a buffer with a live process attached to it:

#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions
	(remq 'process-kill-buffer-query-function
	      kill-buffer-query-functions))
#+END_SRC

** Scripts
Do not worry chmod a+x something anymore, let emacs do it.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

Also use ~env~ it is more robust in some circumstances.

#+BEGIN_SRC emacs-lisp
  (setq executable-prefix-env t)
#+END_SRC

** Better Matching
CAsE is dump, ignore.

#+BEGIN_SRC emacs-lisp
  (setq read-buffer-completion-ignore-case t
	read-file-name-completion-ignore-case t)
#+END_SRC

** History
Make History a bit longer.

#+BEGIN_SRC emacs-lisp
  (setq-default history-length 10000)
  (setq-default prescient-history-length 10000)
#+END_SRC

Persistent History, have some persistency.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook #'savehist-mode)
  (setq savehist-additional-variables '(mark-ring
					global-mark-ring
					search-ring
					regexp-search-ring
					extended-command-history)
	savehist-autosave-interval 300)
#+END_SRC

** Understand the more common ~sentence~
By default, Emacs thinks a sentence is a full-stop followed by 2 spaces. Let’s make it full-stop and 1 space.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

** Goto Error
Center after going to the next error.

#+BEGIN_SRC emacs-lisp
  (setq next-error-recenter (quote (4)))
#+END_SRC

** Hide Point
Hide the cursor in inactive windows.

#+BEGIN_SRC emacs-lisp
  (setq cursor-in-non-selected-windows nil)
#+END_SRC

** Trashing
Use the system trashing utility iff available.

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

** Fewer Reads
By increasing the maximal read size from a process, we decrease calls to read.
Motivation is not living in the 80s, we have the memory. This should not
increase the pipe maximal size!

#+BEGIN_SRC emacs-lisp
  (setq read-process-output-max (* 2 1024 1024))
#+END_SRC

** Auto revert
Reload file that changed on disk. We can always go back due to undo-tree.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
#+END_SRC

Do the same for remote files.

#+BEGIN_SRC emacs-lisp
  (setq auto-revert-remote-files t)
#+END_SRC

** Tail Messages Buffer
Tail the messages buffer when not in focus.

#+BEGIN_SRC emacs-lisp
  (defvar +messages--auto-tail-enabled nil)
  (defun +messages--auto-tail-a (&rest arg)
    "Make *Messages* buffer auto-scroll to the end after each message. ARG."
    (let* ((buf-name (buffer-name (messages-buffer)))
	   ;; Create *Messages* buffer if it does not exist
	   (buf (get-buffer-create buf-name)))
      ;; Activate this advice only if the point is _not_ in the *Messages* buffer
      ;; to begin with. This condition is required; otherwise you will not be
      ;; able to use `isearch' and other stuff within the *Messages* buffer as
      ;; the point will keep moving to the end of buffer :P
      (when (not (string= buf-name (buffer-name)))
	;; Go to the end of buffer in all *Messages* buffer windows that are
	;; *live* (`get-buffer-window-list' returns a list of only live windows).
	(dolist (win (get-buffer-window-list buf-name nil :all-frames))
	  (with-selected-window win
	    (goto-char (point-max))))
	;; Go to the end of the *Messages* buffer even if it is not in one of
	;; the live windows.
	(with-current-buffer buf
	  (goto-char (point-max))))))
  (defun +messages-auto-tail-toggle ()
    "Auto tail the '*Messages*' buffer."
    (interactive)
    (if +messages--auto-tail-enabled
	(progn
	  (advice-remove 'message '+messages--auto-tail-a)
	  (setq +messages--auto-tail-enabled nil))
      (advice-add 'message :after '+messages--auto-tail-a)
      (setq +messages--auto-tail-enabled t)))
  (+messages-auto-tail-toggle)
#+END_SRC

** Sub-word-mode
Most projects I work on use Camel-Case (ugh!).

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

** Date and Time
Use YYYY-MM-DD date format.

#+BEGIN_SRC emacs-lisp
  (setq calendar-date-style 'iso)
#+END_SRC

** Trailing Whitespace
Clean up trailing whitespaces automatically.

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :diminish
    ;; ws-butler normally preserves whitespace in the buffer (but strips it from
    ;; the written file). While sometimes convenient, this behavior is not
    ;; intuitive. To the average user it looks like whitespace cleanup is failing,
    ;; which causes folks to redundantly install their own.
    :custom
    (ws-butler-keep-whitespace-before-point nil)
    :init
    (ws-butler-global-mode +1))
#+END_SRC

This should not be possible but if ws-butler fails show it.

#+BEGIN_SRC emacs-lisp
(setq show-trailing-whitespace t)
#+END_SRC

** Auto Minor Mode
Better minor mode deduction.

#+BEGIN_SRC emacs-lisp
(use-package auto-minor-mode
  :diminish
  :demand t)
#+END_SRC

** Final Newline
Self-explanatory.

#+BEGIN_SRC emacs-lisp
(setq-default require-final-newline nil)
#+END_SRC

** Path from shell
On Linux Emacs doesn't use the shell PATH if it's not started from
the shell. Let's fix that:

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :init
  (exec-path-from-shell-initialize))
#+END_SRC

** Icons
Nice visual features.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :if (display-graphic-p)
  :commands (all-the-icons-octicon
	     all-the-icons-faicon
	     all-the-icons-fileicon
	     all-the-icons-wicon
	     all-the-icons-material
	     all-the-icons-alltheicon))

(use-package all-the-icons-dired
  :if (display-graphic-p)
  :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC

** Eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :straight (eldoc :type built-in)
    :config
    (setq eldoc-idle-delay 0.0)
    :init
    (global-eldoc-mode))
#+END_SRC

* Keybindings
I use =general= for better keybindings.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :straight (general :type git :host github :repo "noctuid/general.el")
    :demand t
    :config
    (general-evil-setup t))
#+END_SRC

Define leader keys.
#+BEGIN_SRC emacs-lisp
  (defconst +leader-key
    "SPC"
    "The global leader key for EVIl.")

  (defconst +local-leader-key
    "SPC m"
    "The local leader key for EVIl.")
#+END_SRC

* Evil
At some point I got used to =vim= keybindings.
Now, I cannot go back.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :straight (evil :type git :host github :repo "emacs-evil/evil")
    :demand t
    :preface
    (setq evil-want-keybinding nil)
    :init
    (evil-mode)
    :custom
    (evil-want-integration t)
    (evil-want-C-g-bindings t)
    (evil-want-C-i-jump nil)
    (evil-want-C-u-scroll t)
    (evil-want-C-u-delete t)
    (evil-want-Y-yank-to-eol t)
    (evil-want-abbrev-expand-on-insert-exit nil)
    (evil-respect-visual-line-mode nil)
    (evil-ex-search-vim-style-regexp t)
    (evil-ex-visual-char-range t)
    (evil-mode-line-format 'nil)
    (evil-symbol-word-search t)
    (evil-default-cursor '+evil-default-cursor-fn)
    (evil-normal-state-cursor 'box)
    (evil-emacs-state-cursor  '(box +evil-emacs-cursor-fn))
    (evil-insert-state-cursor 'bar)
    (evil-visual-state-cursor 'hollow)
    (evil-ex-interactive-search-highlight 'selected-window)
    (evil-kbd-macro-suppress-motion-error t)
    (evil-visual-update-x-selection-p nil)
    :config
    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-set-undo-system 'undo-tree)
    (setq evil-search-module 'evil-search))

  (use-package evil-collection
    :straight (evil-collection :type git :host github :repo "emacs-evil/evil-collection")
    :demand t
    :after evil
    :config
    (evil-collection-init))

  (use-package evil-surround
    :straight (evil-surround :type git :host github :repo "emacs-evil/evil-surround")
    :demand t
    :after evil-collection
    :config
    (global-evil-surround-mode 1))

  (use-package evil-nerd-commenter
    :commands
    (evilnc-comment-operator
     evilnc-inner-comment
     evilnc-outer-commenter)
    :general
    ([remap comment-line] #'evilnc-comment-or-uncomment-lines))
#+END_SRC

* Help
** Which-key
Possibly the greatest package.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init
    (which-key-mode)
    :diminish
    (which-key-mode)
    :custom
    (which-key-idle-delay 0.1)
    (which-key-allow-multiple-replacements t)
    (which-key-sort-order #'which-key-key-order-alpha)
    (which-key-sort-uppercase-first nil)
    (which-key-add-column-padding 1)
    (which-key-max-delay-columns nil)
    (which-key-display-lines 6)
    (which-key-side-window-slot -10)
    :config
    (pushnew!
     which-key-replacement-alist
     '(("" . "\\`+?system-packages[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "\\1"))
     '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "\\1"))
     '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "\\1"))))
#+END_SRC

** Helpful
Help me.

#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :commands
    helpful-callable
    helpful-function
    helpful-variable
    helpful-key
    helpful-at-point
    :general
    ([remap describe-callable]    #'helpful-callable)
    ([remap describe-function]    #'helpful-function)
    ([remap describe-variable]    #'helpful-variable)
    ([remap describe-key]         #'helpful-key)
    ([remap view-emacs-debugging] #'helpful-at-point))
#+END_SRC

* VC
** Basics
Follow symlinks

#+BEGIN_SRC emacs-lisp
  (use-package vc
    :custom
    (vc-command-messages t)
    (vc-follow-symlinks t)
    (vc-git-diff-switches '("-w" "-U3"))
    (vc-handled-backends '(Git))
    (vc-make-backup-files t))
#+END_SRC

** Magit
Possibly the most convincing reason to use EMACS? No, seriously it is awesome.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :hook
    ((magit-process-mode . goto-address-mode))
    :custom
    ;; Update VC line information
    (auto-revert-check-vc-info t)
    ;; Longer commit lines
    (git-commit-summary-max-length 90)
    ;; Show more commits
    (magit-log-section-commit-count 25)
    ;; Do not autosave buffers
    (magit-save-repository-buffers nil)
    ;; Go fullscreen
    (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    ;; Restore previous window configuration
    (magit-bury-buffer-function #'magit-restore-window-configuration)
    ;; Set default clone directory
    (magit-clone-default-directory "~/git/")
    ;; Show more transient levels
    (transient-default-level 7)
    ;; Diffing
    ;; Show granular hunks
    (magit-diff-refine-hunk 'all)
    (magit-diff-refine-ignore-whitespace t)
    (magit-diff-paint-whitespace-lines t)
    :config
    (defvar th/eldoc-git-show-stat--process nil)
    (defun th/eldoc-git-show-stat (callback commit)
      "Compute diffstat for COMMIT asynchronously, then call CALLBACK with it."
      ;; Kill the possibly still running old process and its buffer.
      (when (processp th/eldoc-git-show-stat--process)
	(let ((buf (process-buffer th/eldoc-git-show-stat--process)))
	  (when (process-live-p th/eldoc-git-show-stat--process)
	    (let (confirm-kill-processes)
	      (kill-process th/eldoc-git-show-stat--process)))
	  (when (buffer-live-p buf)
	    (kill-buffer buf))))

      ;; Spawn a new "git show" process.
      (let* ((cmd (list "git" "--no-pager" "show"
			"--no-color"
			;; Author Name <author@email.com>, <date-and-time>
			"--format=format:%an <%ae>, %aD"
			"--stat=80"
			commit)))
	;; An async eldoc-documentation-function must also return a non-nil,
	;; non-string result if it's applicable for computing a documentation
	;; string, so we set and return the new process here.
	(setq th/eldoc-git-show-stat--process
	      (make-process
	       :name "eldoc-git-show"
	       :buffer (generate-new-buffer " *git-show-stat*")
	       :noquery t
	       :command cmd
	       :sentinel (lambda (proc _event)
			   (when (eq (process-status proc) 'exit)
			     (with-current-buffer (process-buffer proc)
			       (goto-char (point-min))
			       (put-text-property (point-min)
						  (line-end-position)
						  'face 'bold)
			       (funcall callback (buffer-string)))))))))
    (defvar th/magit-eldoc-last-commit nil)
    (defun th/magit-eldoc-for-commit (callback)
      (let ((commit (magit-commit-at-point)))
	(when (and commit
		   (not (equal commit th/magit-eldoc-last-commit)))
	  (setq th/magit-eldoc-last-commit commit)
	  (th/eldoc-git-show-stat callback commit))))

    (defun th/magit-eldoc-setup ()
      (add-hook 'eldoc-documentation-functions
		#'th/magit-eldoc-for-commit nil t))

    (add-hook 'magit-status-mode-hook #'th/magit-eldoc-setup)
    (add-hook 'magit-log-mode-hook #'th/magit-eldoc-setup))
#+END_SRC

* Undo
Few understand emacs' kill ring, me included.
Hence Something visually appealing.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :demand t
    :diminish
    :custom
    ;; Show a diff window displaying changes between undo nodes.
    (undo-tree-visualizer-diff t)
    ;; Prevent undo tree files from polluting your git repo
    (undo-tree-history-directory-alist '(("." . "~/.emacs.d/var/undo-tree-hist")))
    :config
    (global-undo-tree-mode +1)
    (setq undo-tree-visualizer-diff t
	  undo-tree-auto-save-history t
	  undo-tree-visualizer-timestamps t
	  undo-tree-enable-undo-in-region t))
#+END_SRC

* Org
** Shortcuts
*** Fast SRC_BLOCK
#+BEGIN_SRC emacs-lisp
  (defun org-insert-src-block (src-code-type)
    "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
    (interactive (let ((src-code-types '("emacs-lisp" "python" "C" "sh" "java" "js"
					 "clojure" "C++" "css" "calc" "asymptote" "dot" "gnuplot" "ledger"
					 "lilypond" "mscgen" "octave" "oz" "plantuml" "R" "sass" "screen" "sql"
					 "awk" "ditaa" "haskell" "latex" "lisp" "matlab" "ocaml" "org" "perl"
					 "ruby" "scheme" "sqlite")))
		   (list (ido-completing-read "Source code type: " src-code-types))))
    (progn (insert (format "#+BEGIN_SRC %s\n" src-code-type))
	   (insert "#+END_SRC\n") (previous-line 2) (org-edit-src-code)))

  (add-hook 'org-mode-hook #'(lambda () ;; keybinding for editing source code blocks
			       (local-set-key (kbd "C-c i e") 'org-edit-src-code) ;; keybinding for inserting code blocks
			       (local-set-key (kbd "C-c i s")
  'org-insert-src-block)))
#+END_SRC

* Programming
** Formatting
#+BEGIN_SRC emacs-lisp
  (use-package apheleia
    :straight (apheleia :type git :host github :repo "radian-software/apheleia")
    :diminish
    :hook prog-mode
    :init
    (apheleia-global-mode +1)
    :config
    ;; Also enable lisp indentation in emacs-lisp
    (push '(emacs-lisp-mode . lisp-indent) apheleia-mode-alist))
#+END_SRC

** Smartparens
Giving parenthesis some brains.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :diminish
    :hook prog-mode
    :commands sp-pair sp-local-pair sp-with-modes sp-point-in-comment sp-point-inside-string
    :custom
    ;; Overlays are too distracting and not terribly helpful. `show-paren-mode' does
    ;; this for us already (and is faster), so...
    (sp-highlight-pair-overlay nil)
    (sp-highlight-wrap-overlay nil)
    (sp-highlight-wrap-tag-and-overlay nil)
    ;; The default is 100, because smartparen's scans are relatively expensive
    ;; (especially with large pair lists for some modes), we reduce it, as a
    ;; better compromise between performance and accuracy.
    (sp-max-prefix-length 25)
    ;; No pair has any business being longer than 4 characters; if they must, set
    ;; it buffer-locally. It's less work for smartparens.
    (sp-max-pair-length 4)
    :config
    (require 'smartparens-config)
    (with-eval-after-load 'evil
      ;; But if someone does want overlays enabled, evil users will be stricken
      ;; with an off-by-one issue where smartparens assumes you're outside the
      ;; pair when you're really at the last character in insert mode. We must
      ;; correct this vile injustice.
      (setq sp-show-pair-from-inside t)
      ;; ...and stay highlighted until we've truly escaped the pair!
      (setq sp-cancel-autoskip-on-backward-movement nil)
      ;; Smartparens conditional binds a key to C-g when sp overlays are active
      ;; (even if they're invisible). This disruptively changes the behavior of
      ;; C-g in insert mode, requiring two presses of the key to exit insert mode.
      ;; I don't see the point of this keybind, so...
      (setq sp-pair-overlay-keymap (make-sparse-keymap))))
#+END_SRC

* EOF
Here, I add the ability to tangle this file automatically when changed and
subsequently saved.

** Tangle Config File
A simple function that tangles this file.

#+BEGIN_SRC emacs-lisp
  (defun +tangle-config () "Tangle the `+config-file'."	 (message "Start
  tangling.")  (require 'org) (org-babel-tangle-file +config-file
  (file-name-concat user-emacs-directory "init.el") "emacs-lisp")
  (message "Successfully tangled config file."))
#+END_SRC

** Add-hook
Emacs considers some file local variables unsafe, e.g., =after-save-hook=.
Hence, I add it as a safe pair, with =+tangle-config= function, to the
=safe-local-variable-values= variable.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'safe-local-variable-values '(after-save-hook
  . +tangle-config))
#+END_SRC

Installs a file local hook, to tangle this file.
# Local Variables: after-save-hook: +tangle-config End:
